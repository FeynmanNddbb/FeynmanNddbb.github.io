<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链</title>
      <link href="/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/"/>
      <url>/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="焦化工艺全景解析"><a href="#焦化工艺全景解析" class="headerlink" title="焦化工艺全景解析"></a>焦化工艺全景解析</h1><p>炼焦是将煤炭在隔绝空气的条件下高温加热，分解生成焦炭、焦炉煤气和多种化学产品的过程。它是钢铁工业的基石，为高炉炼铁提供不可或缺的燃料和还原剂——焦炭。</p><p>以下将从流程与设备、产品与副产品两个方面进行基础介绍。</p><hr><h2 id="一、流程与设备相关名词"><a href="#一、流程与设备相关名词" class="headerlink" title="一、流程与设备相关名词"></a>一、流程与设备相关名词</h2><ul><li><p><strong>炼焦煤 (Coking Coal)</strong><br>具有一定结焦性的烟煤，是生产焦炭的主要原料。并非所有煤都能炼焦，需要经过配煤来达到最佳效果。</p></li><li><p><strong>配煤 (Coal Blending)</strong><br>将不同种类、不同性质的炼焦煤按一定比例配合使用。目的是在保证焦炭质量的前提下，降低生产成本，合理利用煤炭资源。</p></li><li><p><strong>焦炉 (Coke Oven)</strong><br>炼焦的核心设备，是一种隔焰加热的狭长式炭化室。现代焦炉通常由数十个炭化室和燃烧室交替排列组成。</p><ul><li><strong>炭化室 (Coking Chamber)</strong>：装煤并隔绝空气进行干馏的地方。</li><li><strong>燃烧室 (Heating Flue)</strong>：位于炭化室两侧，燃烧煤气为炭化室提供热源。</li><li><strong>炉组 (Battery)</strong>：多个焦炉组成的生产单元。</li></ul></li><li><p><strong>结焦时间 (Coking Time)</strong><br>煤料在炭化室内从装炉到炼成焦炭并推出所需的时间，通常为15-24小时。</p></li><li><p><strong>推焦 (Pushing)</strong><br>结焦过程结束后，用推焦机将成熟的赤热焦炭从炭化室推出。</p></li><li><p><strong>熄焦 (Coke Quenching)</strong><br>将赤热红焦冷却熄灭的过程。</p><ul><li><strong>湿法熄焦 (Wet Quenching)</strong>：用大量水喷淋冷却。成本低但耗水、污染大，且焦炭质量受影响。</li><li><strong>干法熄焦 (CDQ - Coke Dry Quenching)</strong>：用惰性气体（如氮气）在密闭系统中冷却红焦。回收红焦显热用于发电，环保且能提高焦炭质量，是现代焦化厂的主流技术。</li></ul></li><li><p><strong>筛焦 (Coke Screening)</strong><br>将熄灭后的焦炭按不同块度进行筛分，分级送往高炉或其它用户。</p></li></ul><hr><h2 id="二、产品与副产品相关名词"><a href="#二、产品与副产品相关名词" class="headerlink" title="二、产品与副产品相关名词"></a>二、产品与副产品相关名词</h2><ol><li><p><strong>焦炭 (Coke)</strong></p><ul><li>炼焦得到的最主要产品，是一种银灰色、坚硬多孔的固体燃料。其核心作用：<ul><li>燃料：在高炉中燃烧提供热量。</li><li>还原剂：产生CO气体将铁矿石中的铁还原出来。</li><li>料柱骨架：支撑高炉中的炉料，保证透气性。</li></ul></li></ul></li><li><p><strong>焦炉煤气 (Coke Oven Gas, COG)</strong></p><ul><li>炼焦过程中产生的气体副产品。主要成分是氢气（H₂）和甲烷（CH₄），并含有少量一氧化碳（CO）、二氧化碳（CO₂）、氮气（N₂）和烃类。</li><li>特点：热值高（约18000 kJ&#x2F;m³），是一种清洁优质的燃气。</li><li>用途：经净化后可作为工业燃料、城市煤气，也可作为化工原料提取氢气等。大量焦炉煤气会返回用于加热焦炉自身。</li></ul></li><li><p><strong>高炉煤气 (Blast Furnace Gas, BFG)</strong></p><ul><li>来源：高炉炼铁过程中产生的主要副产品。</li><li>定义：高炉内焦炭与鼓入热风反应后的炉顶气体。主要成分是氮气（N₂）和一氧化碳（CO），并含有少量二氧化碳（CO₂）和氢气（H₂）。</li><li>特点：因被氮气大量稀释，其热值很低（约3000-4000 kJ&#x2F;m³），但产量巨大。富含CO，有剧毒。</li><li>用途：钢铁厂内重要的低品位燃料，主要用于加热热风炉、电厂发电等。</li></ul></li><li><p><strong>转炉煤气 (Linz-Donawitz Gas, LDG &#x2F; BOF Gas)</strong></p><ul><li>来源：转炉炼钢过程中产生的主要副产品。</li><li>定义：吹氧炼钢时，铁水中的碳被氧化生成的气体。主要成分是一氧化碳（CO），浓度极高（可达60%-70%）。</li><li>特点：热值中等（约7000-8000 kJ&#x2F;m³），CO纯度最高。间歇性、不连续产生，富含粉尘，回收技术要求高。</li><li>用途：经净化回收后，是价值很高的燃料，与COG、BFG混合后用于轧钢加热或高效发电。</li></ul></li><li><p><strong>煤焦油 (Coal Tar)</strong></p><ul><li>炼焦过程中回收的黑色粘稠液体，是多种有机物的复杂混合物。</li><li>加工产品：通过蒸馏可得到轻油、酚油、萘油、洗油、蒽油和沥青等，是制造塑料、染料、药品、农药、合成纤维等的重要化工原料。</li></ul></li><li><p><strong>粗苯 (Crude Benzene)</strong></p><ul><li>从焦炉煤气中回收的轻质油，主要成分为苯、甲苯、二甲苯等。</li><li>用途：经精制后得到的纯苯、甲苯等是重要的基本化工原料，用于生产合成树脂、纤维、橡胶、染料等。</li></ul></li><li><p><strong>氨 (Ammonia)</strong></p><ul><li>煤气中的含氮物质转化而来，通常以硫酸铵（(NH₄)₂SO₄，俗称硫铵）的形式回收。</li><li>用途：主要用作化肥。</li></ul></li></ol><hr><h2 id="三种煤气对比总结表"><a href="#三种煤气对比总结表" class="headerlink" title="三种煤气对比总结表"></a>三种煤气对比总结表</h2><table><thead><tr><th>特性</th><th>焦炉煤气 (COG)</th><th>高炉煤气 (BFG)</th><th>转炉煤气 (LDG)</th></tr></thead><tbody><tr><td>来源</td><td>炼焦炉</td><td>高炉</td><td>转炉</td></tr><tr><td>热值</td><td>高 (~18000 kJ&#x2F;m³)</td><td>低 (~3500 kJ&#x2F;m³)</td><td>中 (~8000 kJ&#x2F;m³)</td></tr><tr><td>主要成分</td><td>H₂, CH₄</td><td>N₂, CO</td><td>CO</td></tr><tr><td>特点</td><td>高热值、清洁、稳定</td><td>低热值、量大、有毒</td><td>CO纯度高、间歇产生</td></tr><tr><td>核心用途</td><td>优质燃料、化工原料</td><td>内部低品位燃料</td><td>混合增效、高效发电</td></tr></tbody></table><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 焦化 </tag>
            
            <tag> 钢铁 </tag>
            
            <tag> 能源 </tag>
            
            <tag> 工业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论专区</title>
      <link href="/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/"/>
      <url>/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="赛博树洞"><a href="#赛博树洞" class="headerlink" title="赛博树洞"></a>赛博树洞</h1><h2 id="欢迎来到本博客最欢乐的角落！"><a href="#欢迎来到本博客最欢乐的角落！" class="headerlink" title="欢迎来到本博客最欢乐的角落！"></a>欢迎来到本博客最欢乐的角落！</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 评论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验教训</title>
      <link href="/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/"/>
      <url>/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件扩展名大小写的影响总结"><a href="#1-文件扩展名大小写的影响总结" class="headerlink" title="1.文件扩展名大小写的影响总结"></a>1.文件扩展名大小写的影响总结</h2><p>在文件管理和 Web 开发中，文件扩展名的大小写可能会导致访问异常，尤其是在不同操作系统下表现不同。</p><h3 id="为什么大小写有影响？"><a href="#为什么大小写有影响？" class="headerlink" title="为什么大小写有影响？"></a>为什么大小写有影响？</h3><ul><li><p><strong>Windows 系统</strong><br>文件路径通常不区分大小写。例如，<code>image.jpg</code> 和 <code>image.JPG</code> 被视为同一个文件，因此本地预览时不会出现问题。</p></li><li><p><strong>Linux&#x2F;Unix 系统</strong><br>大多数 Web 服务器运行在 Linux 或 Unix 系统上，这些系统区分大小写。<code>image.jpg</code> 和 <code>image.JPG</code> 会被当作两个不同的文件。</p></li></ul><h3 id="常见问题举例"><a href="#常见问题举例" class="headerlink" title="常见问题举例"></a>常见问题举例</h3><p>如果配置文件中写的是 <code>/images/wechat.jpg</code>，但实际上传的文件名是 <code>wechat.JPG</code>，服务器会找不到 <code>wechat.jpg</code>，导致返回“404 Not Found”错误。</p><blockquote><p><strong>建议</strong>：在上传文件或编写路径时，统一使用小写扩展名，确保本地与服务器环境一致，避免因大小写问题导致资源无法访问。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go项目实战第一天</title>
      <link href="/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-随机数种子与版本变化总结"><a href="#Go-随机数种子与版本变化总结" class="headerlink" title="Go 随机数种子与版本变化总结"></a>Go 随机数种子与版本变化总结</h1><h2 id="随机数种子的作用"><a href="#随机数种子的作用" class="headerlink" title="随机数种子的作用"></a>随机数种子的作用</h2><ul><li>随机数种子（Random Seed）是伪随机数生成器的“起点”，决定了随机数序列的起始位置。</li><li>相同的种子会生成相同的随机数序列，不同的种子会生成不同的序列。</li><li>在 Go 语言中，未设置种子时，默认行为会影响每次运行的随机数结果。</li></ul><h2 id="Go-版本对随机数种子的影响"><a href="#Go-版本对随机数种子的影响" class="headerlink" title="Go 版本对随机数种子的影响"></a>Go 版本对随机数种子的影响</h2><table><thead><tr><th>Go 版本</th><th>随机数种子默认行为</th><th>结果表现</th><th>是否需要手动播种</th></tr></thead><tbody><tr><td>Go &lt; 1.20</td><td>默认种子为固定值（如 1）</td><td>每次运行结果都一样</td><td>需要手动设置种子</td></tr><tr><td>Go ≥ 1.20</td><td>自动使用系统随机源（如 &#x2F;dev&#x2F;urandom）</td><td>每次运行结果都不同</td><td>不需要手动设置种子</td></tr></tbody></table><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go &lt; 1.20 推荐手动播种</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="built_in">println</span>(rand.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 1.20 及以后版本，math&#x2F;rand 包自动播种，使用起来更方便，无需手动设置种子即可获得不同的随机数序列。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第八天</title>
      <link href="/2025/09/10/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E5%A4%A9/"/>
      <url>/2025/09/10/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Go文件处理"><a href="#1-Go文件处理" class="headerlink" title="1.Go文件处理"></a>1.Go文件处理</h1><ul><li><strong>os</strong>：核心库，提供底层文件操作（创建、读写、删除等），大多数场景优先使用。</li><li><strong>io</strong>：提供通用接口（如 Reader&#x2F;Writer），可与文件、网络等数据源交互。</li><li><strong>bufio</strong>：通过缓冲优化性能，减少 I&#x2F;O 操作次数，适合频繁读写场景。</li><li><strong>ioutil</strong>：已弃用，Go 1.16 后相关功能已迁移到 os 和 io 包。</li><li><strong>path&#x2F;filepath</strong>：处理路径，跨平台兼容 Windows&#x2F;Unix 路径分隔符差异。</li></ul><blockquote><p>文件在创建、读取并赋值后要及时关闭，以免资源占用。</p></blockquote><h1 id="2-Go正则表达式使用注意事项"><a href="#2-Go正则表达式使用注意事项" class="headerlink" title="2.Go正则表达式使用注意事项"></a>2.Go正则表达式使用注意事项</h1><h2 id="常用正则表达式语法表"><a href="#常用正则表达式语法表" class="headerlink" title="常用正则表达式语法表"></a>常用正则表达式语法表</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除了换行符）</td></tr><tr><td><code>*</code></td><td>匹配前面的字符 0 次或多次</td></tr><tr><td><code>+</code></td><td>匹配前面的字符 1 次或多次</td></tr><tr><td><code>?</code></td><td>匹配前面的字符 0 次或 1 次</td></tr><tr><td><code>\d</code></td><td>匹配数字字符（等价于 <code>[0-9]</code>）</td></tr><tr><td><code>\w</code></td><td>匹配字母、数字或下划线（等价于 <code>[a-zA-Z0-9_]</code>）</td></tr><tr><td><code>\s</code></td><td>匹配空白字符（包括空格、制表符、换行符等）</td></tr><tr><td><code>[]</code></td><td>匹配括号内的任意一个字符（如 <code>[abc]</code> 匹配 a、b 或 c）</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td></tr><tr><td><code>$</code></td><td>匹配字符串</td></tr></tbody></table><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ul><li>正则表达式的匹配和替换操作可能会消耗较多资源，尤其是在处理大量数据时。</li><li>在性能敏感的场景下，建议谨慎使用正则表达式，必要时考虑优化或采用其他方案。</li></ul><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ul><li>在 Go 语言中，正则表达式中的反斜杠 <code>\</code> 需要写成 <code>\\</code>，因为反斜杠在字符串中也是转义字符。</li><li>示例：<code>\\d</code> 表示匹配数字字符。</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>使用 <code>regexp.Compile</code> 或 <code>regexp.MustCompile</code> 函数时，务必检查返回的错误，以避免程序崩溃。</li><li>推荐做法：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re, err := regexp.Compile(pattern)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>合理使用正则表达式，注意性能和错误处理，能提升程序的健壮性和效率。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 文件处理和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第七天</title>
      <link href="/2025/09/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
      <url>/2025/09/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？"><a href="#1-发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？" class="headerlink" title="1.发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？"></a>1.发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体对方法的调用</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">        Dividend <span class="type">int</span></span><br><span class="line">        Divisor  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DivideError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot divide %d by %d&quot;</span>, e.Dividend, e.Divisor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口对方法的调用</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">        Area() <span class="type">float64</span></span><br><span class="line">        Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.Radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-并发以及通道"><a href="#2-并发以及通道" class="headerlink" title="2.并发以及通道"></a>2.并发以及通道</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- i<span class="comment">//通道接收数据,不能加等号！！那是赋值语句</span></span><br><span class="line">c =&lt;- ch<span class="comment">//通道发送数据</span></span><br></pre></td></tr></table></figure><ul><li>Go 语言通过 Goroutine 和 Channel 实现高效并发，简化了传统线程模型。</li><li><strong>Goroutine</strong>：轻量级线程，使用 <code>go</code> 关键字启动。</li><li><strong>Channel</strong>：用于 Goroutine 之间的数据通信。</li><li><strong>Select 语句</strong>：可同时等待多个 Channel 操作，提升并发处理能力。</li></ul><h3 id="常见并发问题及解决方法"><a href="#常见并发问题及解决方法" class="headerlink" title="常见并发问题及解决方法"></a>常见并发问题及解决方法</h3><ul><li><strong>死锁（Deadlock）</strong>：所有 Goroutine 都在等待数据，程序无法继续。  <ul><li>解决：合理关闭通道，避免无限等待。</li><li>解决：使用 Mutex 或 Channel 进行同步，保证数据安全。</li></ul></li></ul><p><strong>总结</strong>：Go 并发编程简单高效，需注意死锁和数据竞争等问题，合理使用同步工具可提升程序性能和稳定性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 结构体和并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第六天</title>
      <link href="/2025/09/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
      <url>/2025/09/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-递归与迭代的对比总结"><a href="#1-递归与迭代的对比总结" class="headerlink" title="1.递归与迭代的对比总结"></a>1.递归与迭代的对比总结</h2><ul><li><p><strong>递归函数结构</strong><br>包含基准条件（终止递归）和递归条件（函数自身调用，分解问题）。</p></li><li><p><strong>优点</strong>  </p><ul><li>代码简洁，易于理解。</li><li>适合分解为相似子问题的问题，如树遍历、分治算法等。</li></ul></li><li><p><strong>缺点</strong>  </p><ul><li>性能开销较大，递归调用会占用栈空间，递归深度过大可能导致栈溢出。</li><li>调试较困难，递归层次多时不易定位问题。</li></ul></li><li><p><strong>递归与迭代对比</strong></p></li></ul><table><thead><tr><th>特性</th><th>递归</th><th>迭代</th></tr></thead><tbody><tr><td>代码简洁性</td><td>通常更简洁</td><td>可能更冗长</td></tr><tr><td>性能</td><td>可能较慢，占用栈空间</td><td>通常更快，占用较少内存</td></tr><tr><td>适用场景</td><td>适合分解为子问题的问题</td><td>适合线性或简单重复的问题</td></tr></tbody></table><p><strong>总结</strong>：递归适合解决可分解为子问题的复杂场景，代码简洁但有性能和调试上的劣势；迭代适合处理线性、重复性强的问题，性能更优但代码可能冗长。</p><h2 id="2-数值数据类型转换、字符串数据类型转换√"><a href="#2-数值数据类型转换、字符串数据类型转换√" class="headerlink" title="2.数值数据类型转换、字符串数据类型转换√"></a>2.数值数据类型转换、字符串数据类型转换√</h2><h2 id="3-接口类型转换有两种情况：类型断言和类型转换？（方法？）"><a href="#3-接口类型转换有两种情况：类型断言和类型转换？（方法？）" class="headerlink" title="3.接口类型转换有两种情况：类型断言和类型转换？（方法？）"></a>3.接口类型转换有两种情况：类型断言和类型转换？（方法？）</h2><p>1.定义接口、定义结构体；<br>2.结构体实现接口的所有方法；<br>3.结构体赋实例，再赋值给接口变量（数据类型为接口的变量）；<br>4.接口变量直接调用接口方法。</p><p><strong>接口类型变量可以存储任何实现了该接口的类型的值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义接口</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">        Area() <span class="type">float64</span></span><br><span class="line">        Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义结构体 Rectangle</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Long <span class="type">float64</span></span><br><span class="line">Short <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义结构体 Rectangle</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Rectangle 实现 Shape 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Long * c.Short</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (c.Long + c.Short)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Circle 实现 Shape 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s Shape<span class="comment">//接口类型变量可以存储任何实现了该接口的类型的值</span></span><br><span class="line">    <span class="number">4.</span>s= Rectangle&#123;Long: <span class="number">5</span>,Short:<span class="number">3</span>&#125;<span class="comment">//实现了该接口的类型的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;圆形：&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;面积为：&quot;</span>, s.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;周长为：&quot;</span>, s.Perimeter())</span><br><span class="line">s= Circle&#123;Radius: <span class="number">5</span>&#125;<span class="comment">//实现了该接口的类型的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;矩形：&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;面积为：&quot;</span>, s.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;周长为：&quot;</span>, s.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-next-错误处理"><a href="#4-next-错误处理" class="headerlink" title="4.next:错误处理"></a>4.next:错误处理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 递归迭代与接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第五天</title>
      <link href="/2025/09/06/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
      <url>/2025/09/06/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>学了array、slice（其实就是一个容量可变的array）、structure、range遍历各个数组和集合的用法、指针。</p><h1 id="1-Go切片默认容量扩展机制"><a href="#1-Go切片默认容量扩展机制" class="headerlink" title="1.Go切片默认容量扩展机制"></a>1.Go切片默认容量扩展机制</h1><p>在 Go 语言中，切片的容量扩展并不是简单的按需分配，而是结合了<strong>容量翻倍策略</strong>和<strong>内存分配器的大小等级取整</strong>机制。这样设计的目的是提升分配效率、减少内存碎片，并优化整体性能。</p><ul><li>Go 的运行时内存分配器会根据预定义的大小等级分配内存块，而不是每次都精确分配所需字节。</li><li>当切片容量不足时，append 操作会触发扩容，通常采用容量翻倍策略，但最终容量会向上取整到最近的大小等级。</li><li>例如，追加元素后所需容量为 5，但实际分配的容量为 6，因为 6 个 int 能刚好匹配 48 字节的分配等级。</li></ul><p>这种机制虽然可能导致单次分配时多分配一些内存，但能显著提升切片 append 操作的平均性能，减少频繁分配带来的性能损耗。<br>当然，容量也可以自定义！！</p><h2 id="操作过程举例"><a href="#操作过程举例" class="headerlink" title="操作过程举例"></a>操作过程举例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">/* 此时的默认扩容到了6而不是5（2+3） ！！！*/</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Map注意事项"><a href="#2-Map注意事项" class="headerlink" title="2.Map注意事项"></a>2.Map注意事项</h1><p>Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。</p><h1 id="3-指针的易错点"><a href="#3-指针的易错点" class="headerlink" title="3.指针的易错点"></a>3.指针的易错点</h1><p>使用指针所指内容之前，必须先给初始化指针（地址），即有了地址才能找内容，否则为空指针！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>channel的定义和用法？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 切片、集合和指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第四天</title>
      <link href="/2025/09/05/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
      <url>/2025/09/05/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">动词</th><th align="left">含义</th><th align="left">示例（整数255）</th><th align="left">示例（浮点数3.14159）</th></tr></thead><tbody><tr><td align="left"><code>%d</code></td><td align="left"><strong>十进制</strong>表示</td><td align="left"><code>255</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%x</code></td><td align="left"><strong>十六进制</strong>表示，使用<strong>小写</strong>字母 <code>a-f</code></td><td align="left"><code>ff</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%X</code></td><td align="left"><strong>十六进制</strong>表示，使用<strong>大写</strong>字母 <code>A-F</code></td><td align="left"><code>FF</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%p</code></td><td align="left"><strong>专用于打印指针（内存地址）</strong>。以十六进制输出，并加上前缀 <code>0x</code>（推荐方式）</td><td align="left"><code>0xff</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%o</code></td><td align="left"><strong>八进制</strong>表示</td><td align="left"><code>377</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%f</code></td><td align="left"><strong>浮点数十进制</strong>表示，默认6位小数</td><td align="left">不适用</td><td align="left"><code>3.141593</code></td></tr><tr><td align="left"><code>%g</code></td><td align="left"><strong>自动选择</strong> <code>%e</code> 或 <code>%f</code> 格式，产生更紧凑的输出</td><td align="left">不适用</td><td align="left"><code>3.14159</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 输出格式符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第三天</title>
      <link href="/2025/09/04/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2025/09/04/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ul><li><strong>局部变量</strong>：在函数体内声明的变量称为局部变量，其作用域仅限于函数体内部。函数的参数和返回值变量也属于局部变量。</li><li><strong>全局变量</strong>：在函数体外声明的变量称为全局变量，全局变量可以在整个包内，甚至被导出后在外部包中使用。</li><li><strong>使用指针变量与不使用的区别</strong>：指针变量*（地址）的值会跟随变量的变化而变化，对比：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> ptr <span class="type">int</span></span><br><span class="line">    ptr = a </span><br><span class="line">    fmt.Println(ptr)<span class="comment">//4</span></span><br><span class="line">    a = <span class="number">15</span></span><br><span class="line">    fmt.Println(ptr)<span class="comment">//4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span> </span><br><span class="line">    <span class="keyword">var</span> ptr1 *<span class="type">int</span></span><br><span class="line">    ptr1 = &amp;b </span><br><span class="line">    fmt.Println(*ptr1)<span class="comment">//5</span></span><br><span class="line">    b=<span class="number">15</span> </span><br><span class="line">    fmt.Println(*ptr1)<span class="comment">//15 *ptr1的值跟随b的变化而变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注：</strong></p><ol><li>局部变量的生命周期仅在函数调用期间，函数调用结束后局部变量会被销毁。</li><li>Go 语言中，全局变量与局部变量可以同名，但在函数内部会优先使用局部变量。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 变量以及作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第二天</title>
      <link href="/2025/09/03/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2025/09/03/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言学习笔记"><a href="#Go语言学习笔记" class="headerlink" title="Go语言学习笔记"></a>Go语言学习笔记</h2><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ul><li>当标识符（包括常量、变量、类型、函数名、结构字段等）以<strong>大写字母</strong>开头时，如 <code>Group1</code>，该标识符可以被外部包的代码访问（需先导入该包），称为“导出”（类似于面向对象语言中的 <code>public</code>）。</li><li>如果标识符以<strong>小写字母</strong>开头，则对包外不可见，但在包内部可见并可用（类似于面向对象语言中的 <code>protected</code>）。</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul><li>运行 Go 文件：<code>go run hello.go</code></li><li>编译 Go 文件（生成可执行文件）：<code>go build hello.go</code></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>&#123;</code> 不能单独放在一行。</li><li><strong>文件名与包名</strong>没有直接关系，不要求一致。</li><li>同一文件夹下的所有文件<strong>只能有一个包名</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 标识符和常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第一天</title>
      <link href="/2025/09/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2025/09/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="先在官网下载配置了go，然后配环境变量"><a href="#先在官网下载配置了go，然后配环境变量" class="headerlink" title="先在官网下载配置了go，然后配环境变量"></a>先在官网下载配置了go，然后配环境变量</h2><h2 id="又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏"><a href="#又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏" class="headerlink" title="又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏"></a>又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏</h2><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h2 id="1-package-main只能有一个"><a href="#1-package-main只能有一个" class="headerlink" title="1.package main只能有一个"></a>1.package main只能有一个</h2><h2 id="2-感觉包、库管理很像python，而语法和结构又像C"><a href="#2-感觉包、库管理很像python，而语法和结构又像C" class="headerlink" title="2.感觉包、库管理很像python，而语法和结构又像C"></a>2.感觉包、库管理很像python，而语法和结构又像C</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意事项</title>
      <link href="/2025/08/26/%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2025/08/26/%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图片配置注意事项"><a href="#图片配置注意事项" class="headerlink" title="图片配置注意事项"></a>图片配置注意事项</h1><h2 id="图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号-！！）"><a href="#图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号-！！）" class="headerlink" title="图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号~！！）"></a>图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号~！！）</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly的安装和配置</title>
      <link href="/2025/08/25/butterfly%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/08/25/butterfly%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><h3 id="在你的-Hexo-根目录"><a href="#在你的-Hexo-根目录" class="headerlink" title="在你的 Hexo 根目录"></a>在你的 Hexo 根目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h3 id="升級方法：在-Hexo-根目录下，运行"><a href="#升級方法：在-Hexo-根目录下，运行" class="headerlink" title="升級方法：在 Hexo 根目录下，运行"></a>升級方法：在 Hexo 根目录下，运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><h3 id="修改-Hexo-根目錄下的-config-yml，把主題改為-butterfly"><a href="#修改-Hexo-根目錄下的-config-yml，把主題改為-butterfly" class="headerlink" title="修改 Hexo 根目錄下的 _config.yml，把主題改為 butterfly"></a>修改 Hexo 根目錄下的 _config.yml，把主題改為 butterfly</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="如果你沒有-pug-以及-stylus-的渲染器，請下載安裝："><a href="#如果你沒有-pug-以及-stylus-的渲染器，請下載安裝：" class="headerlink" title="如果你沒有 pug 以及 stylus 的渲染器，請下載安裝："></a>如果你沒有 pug 以及 stylus 的渲染器，請下載安裝：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的配置和初始化</title>
      <link href="/2025/08/25/hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2025/08/25/hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0-首先安装好node-js和git（安装基础环境）"><a href="#0-首先安装好node-js和git（安装基础环境）" class="headerlink" title="0.首先安装好node.js和git（安装基础环境）"></a>0.首先安装好node.js和git（安装基础环境）</h2><h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="安装hexo依赖"><a href="#安装hexo依赖" class="headerlink" title="安装hexo依赖"></a>安装hexo依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="2-现在就可以通过hexo命令预览初创hexo网站了！"><a href="#2-现在就可以通过hexo命令预览初创hexo网站了！" class="headerlink" title="2.现在就可以通过hexo命令预览初创hexo网站了！"></a>2.现在就可以通过hexo命令预览初创hexo网站了！</h2><h3 id="清除hexo缓存"><a href="#清除hexo缓存" class="headerlink" title="清除hexo缓存"></a>清除hexo缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br></pre></td></tr></table></figure><h3 id="构建hexo"><a href="#构建hexo" class="headerlink" title="构建hexo"></a>构建hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="本地预览hexo"><a href="#本地预览hexo" class="headerlink" title="本地预览hexo"></a>本地预览hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="上传hexo"><a href="#上传hexo" class="headerlink" title="上传hexo"></a>上传hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/08/25/hello-world/"/>
      <url>/2025/08/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 梦开始的地方 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
