<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链</title>
      <link href="/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/"/>
      <url>/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="焦化工艺全景解析"><a href="#焦化工艺全景解析" class="headerlink" title="焦化工艺全景解析"></a>焦化工艺全景解析</h1><p>炼焦是将煤炭在隔绝空气的条件下高温加热，分解生成焦炭、焦炉煤气和多种化学产品的过程。它是钢铁工业的基石，为高炉炼铁提供不可或缺的燃料和还原剂——焦炭。</p><p>以下将从流程与设备、产品与副产品两个方面进行基础介绍。</p><hr><h2 id="一、流程与设备相关名词"><a href="#一、流程与设备相关名词" class="headerlink" title="一、流程与设备相关名词"></a>一、流程与设备相关名词</h2><ul><li><p><strong>炼焦煤 (Coking Coal)</strong><br>具有一定结焦性的烟煤，是生产焦炭的主要原料。并非所有煤都能炼焦，需要经过配煤来达到最佳效果。</p></li><li><p><strong>配煤 (Coal Blending)</strong><br>将不同种类、不同性质的炼焦煤按一定比例配合使用。目的是在保证焦炭质量的前提下，降低生产成本，合理利用煤炭资源。</p></li><li><p><strong>焦炉 (Coke Oven)</strong><br>炼焦的核心设备，是一种隔焰加热的狭长式炭化室。现代焦炉通常由数十个炭化室和燃烧室交替排列组成。</p><ul><li><strong>炭化室 (Coking Chamber)</strong>：装煤并隔绝空气进行干馏的地方。</li><li><strong>燃烧室 (Heating Flue)</strong>：位于炭化室两侧，燃烧煤气为炭化室提供热源。</li><li><strong>炉组 (Battery)</strong>：多个焦炉组成的生产单元。</li></ul></li><li><p><strong>结焦时间 (Coking Time)</strong><br>煤料在炭化室内从装炉到炼成焦炭并推出所需的时间，通常为15-24小时。</p></li><li><p><strong>推焦 (Pushing)</strong><br>结焦过程结束后，用推焦机将成熟的赤热焦炭从炭化室推出。</p></li><li><p><strong>熄焦 (Coke Quenching)</strong><br>将赤热红焦冷却熄灭的过程。</p><ul><li><strong>湿法熄焦 (Wet Quenching)</strong>：用大量水喷淋冷却。成本低但耗水、污染大，且焦炭质量受影响。</li><li><strong>干法熄焦 (CDQ - Coke Dry Quenching)</strong>：用惰性气体（如氮气）在密闭系统中冷却红焦。回收红焦显热用于发电，环保且能提高焦炭质量，是现代焦化厂的主流技术。</li></ul></li><li><p><strong>筛焦 (Coke Screening)</strong><br>将熄灭后的焦炭按不同块度进行筛分，分级送往高炉或其它用户。</p></li></ul><hr><h2 id="二、产品与副产品相关名词"><a href="#二、产品与副产品相关名词" class="headerlink" title="二、产品与副产品相关名词"></a>二、产品与副产品相关名词</h2><ol><li><p><strong>焦炭 (Coke)</strong></p><ul><li>炼焦得到的最主要产品，是一种银灰色、坚硬多孔的固体燃料。其核心作用：<ul><li>燃料：在高炉中燃烧提供热量。</li><li>还原剂：产生CO气体将铁矿石中的铁还原出来。</li><li>料柱骨架：支撑高炉中的炉料，保证透气性。</li></ul></li></ul></li><li><p><strong>焦炉煤气 (Coke Oven Gas, COG)</strong></p><ul><li>炼焦过程中产生的气体副产品。主要成分是氢气（H₂）和甲烷（CH₄），并含有少量一氧化碳（CO）、二氧化碳（CO₂）、氮气（N₂）和烃类。</li><li>特点：热值高（约18000 kJ&#x2F;m³），是一种清洁优质的燃气。</li><li>用途：经净化后可作为工业燃料、城市煤气，也可作为化工原料提取氢气等。大量焦炉煤气会返回用于加热焦炉自身。</li></ul></li><li><p><strong>高炉煤气 (Blast Furnace Gas, BFG)</strong></p><ul><li>来源：高炉炼铁过程中产生的主要副产品。</li><li>定义：高炉内焦炭与鼓入热风反应后的炉顶气体。主要成分是氮气（N₂）和一氧化碳（CO），并含有少量二氧化碳（CO₂）和氢气（H₂）。</li><li>特点：因被氮气大量稀释，其热值很低（约3000-4000 kJ&#x2F;m³），但产量巨大。富含CO，有剧毒。</li><li>用途：钢铁厂内重要的低品位燃料，主要用于加热热风炉、电厂发电等。</li></ul></li><li><p><strong>转炉煤气 (Linz-Donawitz Gas, LDG &#x2F; BOF Gas)</strong></p><ul><li>来源：转炉炼钢过程中产生的主要副产品。</li><li>定义：吹氧炼钢时，铁水中的碳被氧化生成的气体。主要成分是一氧化碳（CO），浓度极高（可达60%-70%）。</li><li>特点：热值中等（约7000-8000 kJ&#x2F;m³），CO纯度最高。间歇性、不连续产生，富含粉尘，回收技术要求高。</li><li>用途：经净化回收后，是价值很高的燃料，与COG、BFG混合后用于轧钢加热或高效发电。</li></ul></li><li><p><strong>煤焦油 (Coal Tar)</strong></p><ul><li>炼焦过程中回收的黑色粘稠液体，是多种有机物的复杂混合物。</li><li>加工产品：通过蒸馏可得到轻油、酚油、萘油、洗油、蒽油和沥青等，是制造塑料、染料、药品、农药、合成纤维等的重要化工原料。</li></ul></li><li><p><strong>粗苯 (Crude Benzene)</strong></p><ul><li>从焦炉煤气中回收的轻质油，主要成分为苯、甲苯、二甲苯等。</li><li>用途：经精制后得到的纯苯、甲苯等是重要的基本化工原料，用于生产合成树脂、纤维、橡胶、染料等。</li></ul></li><li><p><strong>氨 (Ammonia)</strong></p><ul><li>煤气中的含氮物质转化而来，通常以硫酸铵（(NH₄)₂SO₄，俗称硫铵）的形式回收。</li><li>用途：主要用作化肥。</li></ul></li></ol><hr><h2 id="三种煤气对比总结表"><a href="#三种煤气对比总结表" class="headerlink" title="三种煤气对比总结表"></a>三种煤气对比总结表</h2><table><thead><tr><th>特性</th><th>焦炉煤气 (COG)</th><th>高炉煤气 (BFG)</th><th>转炉煤气 (LDG)</th></tr></thead><tbody><tr><td>来源</td><td>炼焦炉</td><td>高炉</td><td>转炉</td></tr><tr><td>热值</td><td>高 (~18000 kJ&#x2F;m³)</td><td>低 (~3500 kJ&#x2F;m³)</td><td>中 (~8000 kJ&#x2F;m³)</td></tr><tr><td>主要成分</td><td>H₂, CH₄</td><td>N₂, CO</td><td>CO</td></tr><tr><td>特点</td><td>高热值、清洁、稳定</td><td>低热值、量大、有毒</td><td>CO纯度高、间歇产生</td></tr><tr><td>核心用途</td><td>优质燃料、化工原料</td><td>内部低品位燃料</td><td>混合增效、高效发电</td></tr></tbody></table><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 焦化 </tag>
            
            <tag> 钢铁 </tag>
            
            <tag> 能源 </tag>
            
            <tag> 工业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加强学习第一天（四节）</title>
      <link href="/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/"/>
      <url>/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h1><h2 id="变量声明符号-var-和"><a href="#变量声明符号-var-和" class="headerlink" title="变量声明符号 var 和 :="></a>变量声明符号 <code>var</code> 和 <code>:=</code></h2><p>在 go 语言中，我们使用 <code>var</code> 来表示声明一个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>这就是一个标准的变量声明方式，var 符号在最前面，接着就是变量 a，变量后面紧跟着是变量的类型，这里是 string 类型，也就是字符串类型，<code>=</code> 后面是要赋值的具体值</p><p>我们也可以直接声明不赋予初始值，go 语言默认，声明即赋予初始值，那么这里的字符串类型初始值就是一个空字符串 <code>&quot;&quot;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br></pre></td></tr></table></figure><p>go 语言具有类型推断能力，所以我们可以省略类型，让 go 语言的编译器去推断类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>编译器会自动推断 a 为 string 类型</p><p>在函数体内部 (这是一个先决条件) 我们<strong>也</strong>可以使用省略的写法，就是使用一个符号 <code>:=</code> 来充当 <code>var</code> 的角色，也就是初始化的工作，比如说</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个的用法是 <code>[变量] [:=] [初始值]</code> 这三者缺一不可，而且还不能多，不能在 a 后面带有类型，不能省略初始值，且仅限于函数&#x2F;方法内部使用</p><p>go 语言支持多变量同时赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">string</span> = <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">a, b := <span class="string">&quot;hello world&quot;</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure><p>其中，使用 var 进行声明的时候，如果是多个变量同时声明，必须是相同类型；使用 <code>:= </code> 进行多变量赋值时，多个变量可以不同类型，因为全靠编译器推断</p><h2 id="常见的变量声明方式"><a href="#常见的变量声明方式" class="headerlink" title="常见的变量声明方式"></a>常见的变量声明方式</h2><p>从广义上来说，go 语言只有两种变量，包一级的变量和函数一级的变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultValue <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMethod</span><span class="params">(n <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>DefaultValue</code> 就是包级变量，<code>n</code> 就是函数级变量 (也是形式变量)</p><p>下面我列举一些常见的声明方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> a <span class="type">string</span></span><br><span class="line"> b <span class="type">int32</span> = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">//包级变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">  d := <span class="number">12</span> <span class="comment">//仅限函数内部使用，变量后面不能有类型</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">// 函数级变量</span></span><br><span class="line">  <span class="keyword">var</span> e = <span class="string">&quot;hello world&quot;</span> <span class="comment">//自动推断变量类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以说声明的方式很多，不过呢，在一个项目中应该尽量保证声明方式的一致性，因为可以加强代码的统一性，减少理解代码的难度。</p><h2 id="go-语言可导出变量"><a href="#go-语言可导出变量" class="headerlink" title="go 语言可导出变量"></a>go 语言可导出变量</h2><p>go 语言跟一般的语言不同，它使用变量<strong>首</strong>字母的大小写来区分变量的可导出性质，大写 (如果使用中文作为变量名称，默认是可导出的) 代表可导出，小写代表仅限包内部使用 (包这一级，多个文件只要是同一个包就可以使用)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Example</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OutPutName = <span class="number">0o77</span></span><br><span class="line"><span class="keyword">var</span> inName = <span class="number">0x99</span></span><br></pre></td></tr></table></figure><p>其中 <code>OutPutName</code> 是一个可导出的变量，<code>inName</code> 是不可导出变量</p><p>go 语言还拥有比如函数，方法，结构体，接口，等等各类型的组件，这里你可以先不懂到底是什么，你先有一个印象，但凡首字母是大写的都是可以导出的，小写就是包内使用，没错，go 语言就是这么简单</p><h2 id="包级变量"><a href="#包级变量" class="headerlink" title="包级变量"></a>包级变量</h2><p><code>第一种声明形式</code>：<strong>声明的同时，显式初始化</strong></p><ul><li><code>var a = method(&quot;t&quot;)</code> go 编译器根据右侧的返回值自动确定左侧变量的类型</li><li><code>var a = 3.14</code> 在没有具体返回值，没有具体类型的情况下，go 赋予它默认类型，比如 float 的默认类型就是 float64，int 类型的默认类型就是 int</li><li>如果要显式的赋予类型，并且保证命名的一致性 <code>var a int = 12</code> 的行为应该避免，应该写成 <code>var a = int(12)</code> 用来保证一致性<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  a = <span class="number">3.14</span></span><br><span class="line">  b = <span class="type">int</span>(<span class="number">12</span>)</span><br><span class="line">  e = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p><code>第二种声明形式</code>：<strong>声明但是延迟初始化</strong></p><p>只有 <code>var a int64</code> 这一种方式，不过呢，go 语言的声明是直接赋予零值的，比如说这里的 a 默认就是 <code>0</code></p><p>go 语言变量声明的聚集和就近原则：将同一类型的放在一个 var() 内部；或者另一种分类方法：将有初始值的放在一个 var 里，将延迟初始化的放在另一个 var 里。</p><p>分类一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">int</span></span><br><span class="line">c <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">d <span class="type">string</span></span><br><span class="line">e <span class="type">string</span></span><br><span class="line">f <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>分类二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  a = <span class="number">12</span></span><br><span class="line">  b = <span class="string">&quot;string&quot;</span></span><br><span class="line">  c = <span class="string">&quot;string&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  d <span class="type">int</span></span><br><span class="line">  c <span class="type">string</span></span><br><span class="line">  f <span class="type">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接下来谈一谈就近原则，变量的声明和变量的使用尽量的近，不要都声明在头部，如果一个变量被全局大量使用，那么可以放在头部，如果就是仅仅使用少量的次数，还是应该在使用的前面就进进行声明</p><h2 id="函数级变量"><a href="#函数级变量" class="headerlink" title="函数级变量"></a>函数级变量</h2><p><code>第一种声明形式</code>：<strong>延迟初始化</strong></p><p>在函数体内使用 var</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量特别多，也可以使用 <code>var()</code> 的方法在函数内部使用</p><p><code>第二种声明形式</code>：<strong>声明且显式初始化的局部变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="number">12</span></span><br><span class="line">  b := <span class="type">int32</span>(<span class="number">20</span>) <span class="comment">// 改变默认类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小心-shadow-的变量"><a href="#小心-shadow-的变量" class="headerlink" title="小心 shadow 的变量"></a>小心 shadow 的变量</h2><p>我们知道，当有两个两个以上的变量在赋值时，如果其中有一个未被提前声明，那么就需要使用 <code>:=</code>，这个时候系统会自动判断有哪些未提前声明，然而有一种场景下系统会发生误判，准确的来说这是一种歧义，系统的判断会跟程序员的心理不一致，出现了变量 shadow 的行为，让我们看一下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    a,err := example.Method()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a,err := example.Method1()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外层，a 已经提前声明，但是在 if 这个作用域中，由于 err 并未提前声明，所以使用了 <code>:=</code>，由于系统<strong>无法获知</strong>这里的 a 是否需要再次声明，所以 go 语言默认 a 是一个新的变量，这样外层的 a 就无法得到新的值，外层 a 也就被内层的 a 给 shadow 了。</p><p>如果想改变这种 bug，我们可以将 err 也提前声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    a,err = example.Method()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a,err = example.Method1()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者也可以改变内部的变量名称，来改变这种 shadow：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    ai,err := example.Method()</span><br><span class="line">    a = ai</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ai,err := example.Method1()</span><br><span class="line">    a = ai</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-go-语言常量"><a href="#2-go-语言常量" class="headerlink" title="2.go 语言常量"></a>2.go 语言常量</h1><p>go 使用 const 来声明常量，常量表达式的运算在编译期就可以完成了，并且 go 常量是类型安全的，编译器优化友好的元素。</p><p>常量中的数据类型只可以是布尔、数字 (整数、浮点和复数) 以及字符串型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  startOne = <span class="number">-2</span></span><br><span class="line">  startTwo = <span class="number">1.0</span></span><br><span class="line">  startThree = <span class="number">3.14</span></span><br><span class="line">  isTrue = <span class="literal">true</span></span><br><span class="line">  hi = <span class="string">&quot;hi&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>go 推崇无类型常量，这主要是因为 go 不支持隐式的类型转化，只能显式转换，所以一旦常量给定类型，那么它跟变量之间或许就要将常量转化类型才能进行运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PI = <span class="number">3.14</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = PI</span><br><span class="line"><span class="keyword">var</span> b <span class="type">float64</span> = PI</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，如果是没有类型的常量，可以非常灵活的赋予 float32 或者 float64 都可以。</p><h2 id="局部常量"><a href="#局部常量" class="headerlink" title="局部常量"></a>局部常量</h2><p>在 Go 中，局部常量在编译期常量折叠 (compile-time constant folding) 时会被编译器处理成字面值，因此局部常量在编译时会被编译。</p><p>例如，下面的代码定义了一个局部常量 x，并使用它来初始化一个变量 y：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">42</span></span><br><span class="line">    <span class="keyword">var</span> y = x * <span class="number">2</span></span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，x 将被处理成字面值 42，因此编译器将 y 初始化为 84，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">84</span></span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，局部常量在编译期已经被折叠成了字面值，因此在运行时不会再进行计算了。</p><h2 id="常量不可包含计算"><a href="#常量不可包含计算" class="headerlink" title="常量不可包含计算"></a>常量不可包含计算</h2><p>在 Go 中，常量必须在编译时就可以确定其值。因此，常量的值必须是一个编译时的常量表达式，不能包含运行时的计算。</p><p>不过，常量表达式可以包含一些简单的运算，例如加、减、乘、除、取模等算术运算，以及位运算、逻辑运算等。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="number">2</span> + <span class="number">3</span>            <span class="comment">// 常量表达式，结果为 5</span></span><br><span class="line">    y = (x * <span class="number">2</span>) % <span class="number">10</span>     <span class="comment">// 常量表达式，结果为 0</span></span><br><span class="line">    z = x == <span class="number">5</span> || y == <span class="number">0</span> <span class="comment">// 常量表达式，结果为 true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量表达式还可以使用一些内置函数，例如 <code>len</code>、<code>cap</code>、<code>make</code>、<code>new</code> 等，以及可以在编译期计算的一些标准库函数，例如 <code>math.Sin</code>、<code>math.Pi</code> 等。</p><p>总之，常量必须在编译期就可以确定其值，因此不能包含运行时的计算，但可以包含一些简单的算术、位运算、逻辑运算等。</p><h2 id="枚举常量-iota"><a href="#枚举常量-iota" class="headerlink" title="枚举常量 iota"></a>枚举常量 iota</h2><p>go 语言提供隐式重复前一个非空表达式的机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PI = <span class="number">3.14</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(PI, a, b, c, d, e, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将会全部输出 3.14</p><p>iota 是 go 语言的一个预定义标识符，它表示 const 声明块中，每一个常量所处位置的偏移量，它本身也是一个无类型的常量，它的初始值是 0，意思是说此处的 iota 跟第一行比偏移了 0 个位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  f</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同一行的常量 iota 值是一样的，可以理解为偏移量相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a,b = <span class="literal">iota</span></span><br><span class="line">  c,d</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果要让 iota 的初始值是 1，那么可以这么做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  _ = <span class="literal">iota</span></span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 只需要在一个 const 群中出现一次即可，出现多次跟出现一次的效果一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b = <span class="literal">iota</span></span><br><span class="line">  c = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 一样</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当 iota 群中出现异类该如何处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b = <span class="number">12</span></span><br><span class="line">  c = <span class="literal">iota</span></span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  f</span><br><span class="line">  g</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>答案就是异类输出自己的，其它的常量不受影响，比如这里的输出就是 <code>0 12 2 3 4 5 6</code>，只要记住 iota 是偏移位置就可以理解为什么是这么输出的了。</p><p>如果不考虑常量的灵活性，极致追求安全性，那么也可以给 iota 常量加上类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a <span class="type">int</span> = <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这种就要求变量类型必须是 int 才能被这些枚举类型接纳，但是一般常量还是用无类型的较为常见。</p><h1 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3.泛型"></a>3.泛型</h1><p><strong>导读：</strong></p><ul><li>约束</li><li>使用方法</li><li>实现原理</li><li>跟其它语言的泛型进行对比</li><li>用例子学泛型</li><li>issues</li></ul><blockquote><p>泛型需满足 <code>go1.18+</code></p></blockquote><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>go 使用 interface 作为约束，约束的意思是约束了这个泛型都具有哪些实际类型。所以可以理解为，go 将 interface 的职责给扩展了，让接口不仅仅作为接口 — 解耦的，抽象化的结构体，还具有了约束，对于类型的约束作用。</p><p>go 可以将所有的接口 (包括经典接口，和泛型以后的接口) 都用作约束，但是可以不代表应该，要有选择的去使用约束，但是约束并不是都可以作为传统的接口来使用的，例如传统的接口只能存在方法，并不能存在类型，<strong>只要存在类型就自动归纳为约束</strong></p><p>综上所述，第一，约束的概念大于接口，只有传统接口可以作为抽象类型去使用，约束只能存在于函数方法或者类型之中，不能单独使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a1 a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a <span class="keyword">interface</span>&#123;</span><br><span class="line"><span class="type">int</span>|<span class="type">float64</span></span><br><span class="line">get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不能在类型约束之外使用类型 a：接口包含类型约束</span></span><br><span class="line">cannot use <span class="built_in">type</span> a outside a <span class="built_in">type</span> constraint: interface contains <span class="built_in">type</span> constraints</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二，不要把传统接口用在约束的地方，这种用法是不合适的，通常来说传统接口的模式就用作抽象类型的解耦即可 (用了也不错，只是不建议)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">hi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span>[<span class="title">T</span> <span class="title">Writer</span>]<span class="params">(v T)</span></span> &#123;</span><br><span class="line">v.hi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型是类型，约束是类型的约束"><a href="#泛型是类型，约束是类型的约束" class="headerlink" title="泛型是类型，约束是类型的约束"></a>泛型是类型，约束是类型的约束</h3><p>请认识到，泛型是一种类型，约束是一种类型的约束，请不要把约束当作泛型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">int</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 st 约束拥有 int 和 string，请注意这里的 st 是约束，不是泛型类型</p><p>go 内置了很多约束，比如说 any 和 comparable，意思是任何类型和可以比较的类型。以后<em><strong>应该</strong></em>会有一个新的内置约束的包叫做 <code>package constraints</code> 例如 any comparable，Ordered 等等约束都会内置到标准库中</p><p>约束不仅仅可以单独写出来，还可以内置于函数内部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">int</span>| <span class="title">string</span>, <span class="title">B</span> <span class="title">float64</span>| <span class="title">string</span>]<span class="params">(i T,j B)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这种形式下，T 和 B 的约束就是仅限此函数使用</p><p>下面我们看一种形式，这种情况下约束的不仅仅是 string 和 int，而是包含了底层是他们的所有数据，比如说 <code>type DD int</code> 也符合这个约束，请记住只能使用在底层类型上，如果使用 <code>~DD</code> 是不被允许的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span>&#123;</span><br><span class="line">~<span class="type">string</span> | ~<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约束的嵌套"><a href="#约束的嵌套" class="headerlink" title="约束的嵌套"></a>约束的嵌套</h3><p>约束跟接口是一样的也是可以嵌套的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ComparableHasher <span class="keyword">interface</span> &#123;</span><br><span class="line">comparable</span><br><span class="line">Hash() <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ImpossibleConstraint <span class="keyword">interface</span> &#123;</span><br><span class="line">comparable</span><br><span class="line">[]<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意义就是 <strong>and</strong> 的意思就是说这个约束是可以比较的还是必须得支持 <code>hash()uintptr</code></p><p>下面这种方式也是可以的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumericAbs[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">~<span class="type">complex64</span> | ~<span class="type">complex128</span></span><br><span class="line">Abs() T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的类型意思是满足数字类型，下面的意思是满足这个方法，所以最终实现这个约束的对象就是一个数字类型，并且实现了这个接口的 <code>Abs()T</code> 方法。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>当结构体中使用泛型的时候，泛型不能直接作为嵌入使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lockable[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">T <span class="comment">// 正确的方法应该是 t T ； 将 T 作为类型参数，不可直接嵌入</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误提示：<code>embedded field type cannot be a (pointer to a) type parameter</code>；<code>嵌入式字段类型不能是（指向）类型参数</code></p><p>我们再看一下当泛型结构体嵌入到其它结构体中如何使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">T T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 这里使用 A[T] 输入了实际类型，</span></span><br><span class="line">A[T]</span><br><span class="line">T T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出关键点，泛型结构体被嵌入其它结构体的时候，泛型要给实际的类型才可以</p><p>结构体泛型和方法中的泛型做对比：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a A[T])</span></span>Get()&#123;&#125;</span><br></pre></td></tr></table></figure><p>方法里的泛型是可以直接从 struct 定义的地方继承这个泛型 T 的，当这个结构体使用时，指定实际的类型即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d1 d</span><br><span class="line"><span class="keyword">var</span> a  = A[d]&#123;</span><br><span class="line">d1,</span><br><span class="line">&#125;</span><br><span class="line">a.Get()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要没有类型就不是约束，是接口，在go语言中，接口可以充当一个一般类型</span></span><br><span class="line"><span class="keyword">type</span> d <span class="keyword">interface</span> &#123;</span><br><span class="line">get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">T T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A[T])</span></span> Get() &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>约束里的泛型同样不能直接嵌入使用</strong></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="keyword">type</span> B[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误提示：<code>cannot embed a type parameter</code></p><p>泛型只能充当类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EmbeddedParameter[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">uint</span> </span><br><span class="line">me() T </span><br></pre></td></tr></table></figure><p>使用约束中的泛型还是需要注意一下的，稍微有些复杂：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">EmbeddedParameter</span>[<span class="title">T</span>]]<span class="params">(t T)</span></span>T&#123;&#125;</span><br></pre></td></tr></table></figure><p>解释一下，中括号里面泛型的两个 T 表达的意思是不一样的，后面的 T 表达的是<strong>约束里的泛型</strong>，表示 any，前面的 T 表示的是满足后面的这个约束的类型 T，但是这里注意，后面 T 虽然之前定义的时候是 any 但是这里被赋予为 T 之后，改变了，改变为了必须满足约束 <code>EmbeddedParameter</code> 的类型，如果说的通俗点，从 any 变成了，满足 <code>int ｜ uint and 实现 me()T方法 </code> 后文会有代码进行解释。</p><p>当然了，后面的 T 没有也行，如果没有后面的 T 就是相当于不改变后面的 T 的约束类型了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Differ[T1 any] <span class="keyword">interface</span> &#123;</span><br><span class="line">Diff(T1) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClose</span>[<span class="title">T2</span> <span class="title">Differ</span>]<span class="params">(a, b T2)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.Diff(b) &lt; <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当使用了泛型之后，是无法使用断言的，这是非法的，那么如果一定要在运行时的时候去判断类型怎么办呢？答案就是转变成 <code>any</code> (type any &#x3D; interface {}) 即可，因为我们知道任何对象都已经实现了空接口，那么就可以被空接口去转化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GeneralAbsDifference</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">switch</span> any(a).(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span>,</span><br><span class="line"><span class="type">uint</span>, <span class="type">uint8</span>, <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span>, <span class="type">uintptr</span>,</span><br><span class="line"><span class="type">float32</span>, <span class="type">float64</span>:</span><br><span class="line"><span class="keyword">return</span> OrderedAbsDifference(a, b) </span><br><span class="line"><span class="keyword">case</span> <span class="type">complex64</span>, <span class="type">complex128</span>:</span><br><span class="line"><span class="keyword">return</span> ComplexAbsDifference(a, b) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下别名的真实类型是泛型的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliasA = A <span class="comment">// 错误 ❌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliasA = A[<span class="type">int</span>] <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>其中错误的问题是别名不能直接使用泛型类型 <code>cannot use generic type A[T any] without instantiation</code>，它需要泛型实际赋值</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>下面展示一下 go 泛型的基本使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>,Age[<span class="type">int</span>](<span class="number">12</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(t T)</span></span> T&#123;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是函数使用泛型的写法，当函数使用泛型的时候，需要在变量前使用中括号标注泛型的具体约束，然后后面才能使用这个泛型类型，使用泛型函数的时候，中括号是可以省略的 <code>Age(12)</code> 系统会自动推算泛型的具体实现。顺便说一下，泛型类型使用 <code>%v</code> 作为占位符，也就是默认的类型，泛型类型无法进行断言。</p><p>当然了，我么也可以不用 any，自定义一个约束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Age[<span class="type">int</span>](<span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="type">int</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">st</span>]<span class="params">(t T)</span></span> &#123;</span><br><span class="line">fmt.Println((t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了在函数内的泛型，我们在看一下在方法中如何使用泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">new</span>(Age[<span class="type">int</span>]).Post(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dd DD[<span class="type">int</span>]</span><br><span class="line">dd.TT(<span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Age[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">I T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Age[T])</span></span> Post(t T) &#123;</span><br><span class="line">fmt.Println(a.I, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DD[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(dd *DD[T])</span></span>TT(t T)&#123;</span><br><span class="line">fmt.Println(t,<span class="built_in">len</span>(*dd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 age 结构体声明的时候，声明了一个泛型 T，在 struct 体内就可以使用这个 T，方法内部仅可以使用定义在这个结构体对象上的泛型</p><p>下面是一个<strong>错误案例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Age[T])</span></span>Post[B any](t T,b B) &#123;</span><br><span class="line">fmt.Println(a.I, t)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>syntax error: method must have no type parameters</code></p><p>接下来我们看一下，如何使用有类型也有方法的泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d DDD</span><br><span class="line"><span class="keyword">var</span> i DDD</span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">io := AbsDifference[DDD](d, i)</span><br><span class="line">fmt.Println(io)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DDD <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ddd DDD)</span></span> Abs() DDD &#123;</span><br><span class="line"><span class="keyword">return</span> ddd + ddd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumericAbs[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">~<span class="type">complex64</span> | ~<span class="type">complex128</span></span><br><span class="line">Abs() T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbsDifference computes the absolute value of the difference of</span></span><br><span class="line"><span class="comment">// a and b, where the absolute value is determined by the Abs method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsDifference</span>[<span class="title">T</span> <span class="title">NumericAbs</span>[<span class="title">T</span>]]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">d := a - b</span><br><span class="line"><span class="keyword">return</span> d.Abs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>泛型的第一种方法是在编译这个泛型时，使用一个字典，里面包含了这个泛型函数的全部类型信息，然后当运行时，使用函数实例化的时候从这个字典中取出信息进行实例化即可，这种方法会导致执行性能下降，一个实例化类型 <code>int, x=y</code> 可能通过寄存器复制就可以了，但是泛型必须通过内存了 (因为需要字典进行运行时赋值)，不过好处就是不浪费空间</p><p>还有一种方法就是把这个泛型的所有类型全部提前生成，这种方法也有一个巨大的缺点就是代码量直线上升，如果是一个包的情况下还能根据具体的函数调用去实现该实现的类型，如果是包输出的的情况下，那么就得不得不生成所有的类型。</p><p>所以将两者结合在一起或许是最好的选择。</p><p>这种方法是这样的，如果类型的内存分配器&#x2F;垃圾回收器呈现的方式一致的情况下，只给它生成一份代码，然后给它一个字典来区分不同的具体行为，可以最大限度的平衡速度和体积</p><h2 id="跟其它语言的泛型进行对比"><a href="#跟其它语言的泛型进行对比" class="headerlink" title="跟其它语言的泛型进行对比"></a>跟其它语言的泛型进行对比</h2><ul><li>c 语言：本身不具有泛型，需要程序员去实现一个泛型，实现复杂，但是不增加语言的复杂度 (换言之只增加了程序员的)</li><li>c++和 rust：跟 go 基本保持一种方式，就是增加编译器的工作量</li><li>Java：将泛型装箱为 object，在装箱和拆箱擦除类型的过程中，程序执行效率会变低</li></ul><h3 id="为什么-Java-编译器不在编译期就完成泛型的装箱操作呢？"><a href="#为什么-Java-编译器不在编译期就完成泛型的装箱操作呢？" class="headerlink" title="为什么 Java 编译器不在编译期就完成泛型的装箱操作呢？"></a>为什么 Java 编译器不在编译期就完成泛型的装箱操作呢？</h3><p>主要有以下几个原因：</p><ol><li><p>编译期装箱需要编译器对代码细节有完整信息。但是泛型类型信息可能来自其他模块或第三方库，编译器难以完整获取。</p></li><li><p>即使编译器可以提前装箱，也需要代码里有大量反射样板代码来还原原始泛型类型，违背泛型设计初衷。</p></li><li><p>编译期装箱也无法很好处理运行期检查和转换的各种边界情况。</p></li></ol><h2 id="用例子学泛型"><a href="#用例子学泛型" class="headerlink" title="用例子学泛型"></a>用例子学泛型</h2><p>理论学习完了，不使用例子进行复习的话会忘的很快的。跟着我看几个例子吧</p><h3 id="函数泛型-map-filter-reduce"><a href="#函数泛型-map-filter-reduce" class="headerlink" title="函数泛型 map-filter-reduce"></a>函数泛型 <code>map-filter-reduce</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">vM := Map[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i + i</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;map的结果是：%v&quot;</span>, vM)</span><br><span class="line">vF := Filter[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(t <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t &gt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;filter的结果是:%v&quot;</span>, vF)</span><br><span class="line">vR := Reduce[Value, *Result]([]Value&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;tt&quot;</span>, year: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;bb&quot;</span>, year: <span class="number">2</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;7i&quot;</span>, year: <span class="number">3</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;8i&quot;</span>, year: <span class="number">4</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;u4i&quot;</span>, year: <span class="number">5</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;uei&quot;</span>, year: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;uwi&quot;</span>, year: <span class="number">7</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;uti&quot;</span>, year: <span class="number">8</span>&#125;,</span><br><span class="line">&#125;, &amp;Result&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(r *Result, v Value)</span></span> *Result &#123;</span><br><span class="line">r.value = r.value + v.year</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;reduce的结果是：&quot;</span>, vR.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map:类似于洗菜，进去的菜和出来的菜不一样了所以需要两种种类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(arr []T1, f <span class="keyword">func</span>(T1)</span></span> T2) []T2 &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]T2, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">result[k] = f(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter:类似于摘菜，进去的菜和出来的菜是一种，不过量减少了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(arr []T, f <span class="keyword">func</span>(T)</span></span> <span class="type">bool</span>) []T &#123;</span><br><span class="line"><span class="keyword">var</span> result []T</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="keyword">if</span> f(v) &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce:类似于做菜，将菜做成一道料理，所以需要两种类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(arr []T1, zero T2, f <span class="keyword">func</span>(T2, T1)</span></span> T2) T2 &#123;</span><br><span class="line">result := zero</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">result = f(result, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">year <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map的结果是：[2 4 6 8 10] filter的结果是:[3 4 5] reduce的结果是： 36</code></p><h3 id="例子二：方法上的泛型-sets"><a href="#例子二：方法上的泛型-sets" class="headerlink" title="例子二：方法上的泛型 sets"></a>例子二：方法上的泛型 <code>sets</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 Sets的具体类型和Make的具体类型都是int,所以可以正常赋值</span></span><br><span class="line"><span class="keyword">var</span> s Sets[<span class="type">int</span>] = Make[<span class="type">int</span>]()</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">s.Add(<span class="number">1</span>)</span><br><span class="line">s.Add(<span class="number">2</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(s.Contains(<span class="number">3</span>))</span><br><span class="line">fmt.Println(s.Len())</span><br><span class="line">s.Iterate(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">s.Delete(<span class="number">2</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets 一个key  存储对象</span></span><br><span class="line"><span class="keyword">type</span> Sets[T comparable] <span class="keyword">map</span>[T]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make 实例化一个map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span>[<span class="title">D</span> <span class="title">comparable</span>]<span class="params">()</span></span> Sets[D] &#123;</span><br><span class="line"><span class="comment">// 泛型就像一个管道一样，只要实例化的时候管子里的东西一致，那么就是一根管子</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(Sets[D])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向这个sets添加内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Add(t T) &#123;</span><br><span class="line">s[t] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete ,从这个sets中删除内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Delete(t T) &#123;</span><br><span class="line"><span class="built_in">delete</span>(s, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Contains 播报t是否属于这个sets</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Contains(t T) <span class="type">bool</span> &#123;</span><br><span class="line">_, ok := s[t]</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Len sets拥有的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate 迭代器，并且给予每个元素功能</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Iterate(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> s &#123;</span><br><span class="line">f(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map[1:&#123;&#125; 2:&#123;&#125;] false 2 1 2 map[1:&#123;&#125; 2:&#123;&#125;] map[1:&#123;&#125;] </code></p><h3 id="例子三：外部定义的约束-实现一个sort接口类型"><a href="#例子三：外部定义的约束-实现一个sort接口类型" class="headerlink" title="例子三：外部定义的约束 实现一个sort接口类型"></a>例子三：外部定义的约束 <code>实现一个sort接口类型</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~ 代表只要底层满足这些类型也可以算满足约束</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> |</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span> | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> orderedSlice[T Ordered] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedSlice</span>[<span class="title">T</span> <span class="title">Ordered</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">sort.Sort(orderedSlice[T](s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><h3 id="关于泛型中的零值"><a href="#关于泛型中的零值" class="headerlink" title="关于泛型中的零值"></a>关于泛型中的零值</h3><p>在 go 里面对泛型的零值并没有一个所谓的泛型零值可以使用，需要根据不同的实践去实现，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Aget[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">t *T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据实际判断，如果a的t不等于nil再返回，如果是nil就返回一个T类型的nil（意思就是只声明）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Aget[T])</span></span> Approach() T &#123;</span><br><span class="line"><span class="keyword">if</span> a.t != <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="keyword">return</span> *a.t</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r T</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上目前，还没一个确切的泛型的零值，那么我们要做的只能是按照实际来具体分析，按照提案，以后有可能使用 <code>return ...</code> <code>return _</code> <code>return </code> <code>return nil</code> <code>return T&#123;&#125;</code> 这些都是可能的结果，我个人比较喜欢 <code>return T&#123;&#125;</code> 来表示泛型的零值，拭目以待吧。</p><h3 id="无法识别使用了底层数据的其它类型"><a href="#无法识别使用了底层数据的其它类型" class="headerlink" title="无法识别使用了底层数据的其它类型"></a>无法识别使用了底层数据的其它类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewtonSqrt</span>[<span class="title">T</span> <span class="title">Float</span>]<span class="params">(v T)</span></span> T &#123;</span><br><span class="line"><span class="keyword">var</span> iterations <span class="type">int</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">interface</span>&#123;&#125;)(v).(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">float32</span>:</span><br><span class="line">iterations = <span class="number">4</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">iterations = <span class="number">5</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T&quot;</span>, v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Code omitted.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> G = NewtonSqrt(MyFloat(<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p>这里约束 Float 拥有的约束类型是 <code>~float32</code> 和 <code>float64</code> 当在 switch 中定义了 float32 和 flaot64 时，无法识别下面的新类型 MyFloat 即使它的底层时 float32，go 的提议是以后在 switch 中使用 <code>case ~float32:</code> 来解决这个问题，目前尚未解决这个问题</p><h3 id="即便约束一致，类型也是不同的"><a href="#即便约束一致，类型也是不同的" class="headerlink" title="即便约束一致，类型也是不同的"></a>即便约束一致，类型也是不同的</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(dst []T1, src []T2)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> src &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="built_in">len</span>(dst) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">dst[i] = T1(x) <span class="comment">// x 是 T2类型 不能直接转化为 T1类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>T1，和 T2 虽然都是 any 的约束，但是啊，它不是一个类型啊！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy[<span class="type">int</span>,<span class="type">string</span>]() <span class="comment">// 这种情况下，你能说可以直接转化吗？？？</span></span><br></pre></td></tr></table></figure><p>这种代码可以更改一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst[i]= (<span class="keyword">interface</span>&#123;&#125;)(x).(T1)</span><br></pre></td></tr></table></figure><p>确认是一种类型以后才能转化</p><!-- * @Author: shgopher shgopher@gmail.com * @Date: 2022-11-17 20:40:42 * @LastEditors: shgopher shgopher@gmail.com * @LastEditTime: 2023-11-29 11:49:04 * @FilePath: /GOFamily/工程/错误处理/README.md * @Description:  *  * Copyright (c) 2023 by shgopher, All Rights Reserved. --><h1 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h1><h2 id="错误处理的基本认识"><a href="#错误处理的基本认识" class="headerlink" title="错误处理的基本认识"></a>错误处理的基本认识</h2><p>在 go 语言中，没有传统编程语言的 <code>try - catch</code> 操作，go 语言中一切错误都需要显式处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := readFile(<span class="string">&quot;./x&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，我们规定函数返回的最后一个数据是错误接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">(v <span class="type">int</span>)</span></span>(<span class="type">int</span>, <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, fmt.Errorf(<span class="string">&quot;错误x&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接返回一个 err 是一种简单的做法，如果错误比较初级也可以这么做，但是如果想要带有更精确的提示信息，可以在返回的时候 wrap 一层信息：</p><p>就以上文的读取数据为例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := readFile(<span class="string">&quot;./&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;在读取数据的时候发生了错误，错误信息是：%w&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrap 一层信息，对于错误的定位更加高效</p><h2 id="Error-的本质是什么？"><a href="#Error-的本质是什么？" class="headerlink" title="Error 的本质是什么？"></a>Error 的本质是什么？</h2><p>错误处理的核心就是下面这一个 error 的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span>&#123;</span><br><span class="line">Error()<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只要我们的自建类型实现了这个接口，就可以使用很多的错误处理的方法。</p><h3 id="自定义-error"><a href="#自定义-error" class="headerlink" title="自定义 error"></a>自定义 error</h3><p>我们使用 errors.New() 的时候其实就是返回了一个 go 自建的，叫做 errorString 的实现了 error 接口的结构体。<br>这就是自建 error 的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := errors.New(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (0x47fd48,0xc00003e730)</span></span><br></pre></td></tr></table></figure><p>为了防止在比较错误的时候发生错误一致的情况，所以自建 error，返回的实际上是一个指针。</p><blockquote><p>下文会提用什么方法进行比较 err，实际上就是 “两个接口类型是否相等 — 类型一致，值一致”，如果返回的值是指针，那么值肯定就不可能一样了。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 源代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;s&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用 fmt.Errorf() 的时候，其实也是使用的上述方法。</p><p>不过，如果我们使用了占位符 <code>%w</code> 时，将不会使用上述方法，而是使用了 wrapError：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="type">string</span></span><br><span class="line">err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *wrapError)</span></span> Error()<span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *wrapError)</span></span> Unwrap() <span class="type">error</span>&#123;</span><br><span class="line"><span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式主要是为了错误链，那就让我们看一下如何使用错误链的相关操作。</p><h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is()"></a>errors.Is()</h3><p>上文我们说到，错误可以使用 wrap 的方式进行封装，那么如果我们想判断封装的这么多层的错误中，有没有哪一层错误等于我们要的值，可以使用这个函数进行判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := errors.New(<span class="string">&quot;err is now&quot;</span>)</span><br><span class="line">err1 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err)</span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err1)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err2,err) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;是一个错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As()"></a>errors.As()</h3><p>这个方法跟上文的 Is() 类似，只不过它判断的是类型是否一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errS <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *errS)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := &amp;errS&#123;<span class="string">&quot;typical error&quot;</span>&#125;</span><br><span class="line">err1 := fmt.Errorf(<span class="string">&quot;wrap err: %w&quot;</span>, err)</span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;wrap err1: %w&quot;</span>, err1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e *errS</span><br><span class="line"><span class="comment">// 这里的 target 必须使用指针</span></span><br><span class="line"><span class="keyword">if</span> !errors.As(err2, &amp;e) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;TypicalErr is not on the chain of err2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;TypicalErr is on the chain of err2&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(err == e)</span><br></pre></td></tr></table></figure><h3 id="errors-Join"><a href="#errors-Join" class="headerlink" title="errors.Join()"></a>errors.Join()</h3><p>这个方法是将几个错误结合在一起的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err1 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err)</span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err1)</span><br><span class="line">err := errors.Join(err1,err2)</span><br></pre></td></tr></table></figure><h2 id="当错误处理遇到了-defer"><a href="#当错误处理遇到了-defer" class="headerlink" title="当错误处理遇到了 defer"></a>当错误处理遇到了 defer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> xx &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段伪代码的意思是说，当有条件之后，返回一个错误，但是 defer 的内容发生在这个 err 被固定之后，所以 defer 中如果再有错误将不会被处理。</p><p>那么我们该怎么更改呢？</p><p>我想你一定想到了前文我们说过，使用带有变量的返回值是可以将 defer 的值进行返回的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> ( i <span class="type">int</span>, e <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> xx &#123;</span><br><span class="line">e = xx</span><br><span class="line">i = xx</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种写法，defer 中如果发生了错误就会覆盖掉了程序执行中的 err，所以这种方法也是不行的，即使它能照顾到了 defer 中的错误处理。</p><p>我们可以将错误处理都放在 defer 中处理就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> ( i <span class="type">int</span>, e <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> xx &#123;</span><br><span class="line">i = xx</span><br><span class="line">e = xx</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">e1 := f.<span class="built_in">close</span>()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span>  e1 != <span class="literal">nil</span> &#123;</span><br><span class="line">log(e1) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">err = e1</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，两种错误都能处理到了</p><h2 id="错误处理实战的五种方式"><a href="#错误处理实战的五种方式" class="headerlink" title="错误处理实战的五种方式"></a>错误处理实战的五种方式</h2><h3 id="经典的错误处理方式"><a href="#经典的错误处理方式" class="headerlink" title="经典的错误处理方式"></a>经典的错误处理方式</h3><p>每一个步骤分别直接处理错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> age <span class="keyword">interface</span>&#123;</span><br><span class="line">getAge()<span class="type">error</span></span><br><span class="line">putAge()<span class="type">error</span></span><br><span class="line">allAge()<span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">D</span><span class="params">(ag age)</span></span><span class="type">error</span>&#123;</span><br><span class="line"><span class="keyword">if</span> err != ag.getAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != ag.putAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != ag.allAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="屏蔽过程中的错误处理"><a href="#屏蔽过程中的错误处理" class="headerlink" title="屏蔽过程中的错误处理"></a>屏蔽过程中的错误处理</h3><p>将错误放置在对象的内部进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileCopier <span class="keyword">struct</span>&#123;</span><br><span class="line">w *os.File</span><br><span class="line">r *os.File</span><br><span class="line">err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileCopier)</span></span>open(path <span class="type">string</span>)( *os.File,<span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">f.err = err</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(f *FileCopier)</span></span>OpenSrc(path <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f.r,f.err = os.Open(path)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(f *FileCopier)</span></span> CopyFile(src, dst <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> f.r != <span class="literal">nil</span> &#123;</span><br><span class="line">f.r.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> f.w!= <span class="literal">nil</span> &#123;</span><br><span class="line">f.w.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f.w != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Remove(dst)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.opensrc(src)</span><br><span class="line">f.createDst(dst)</span><br><span class="line"><span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不是特别完整，但是从中我们还是可以理解这种将错误放在对象中的写法的技巧。</p><p>首先，错误直接放置在对象自身，在方法中首先去调用这个字段来看是否拥有错误，如果有，直接退出即可</p><p>如果没有错误继续往下走，如果本次方法发生错误就继续将这个错误赋值给这个字段，</p><p>当最后处理的方法时，这里也就是 copyfile 方法，我们在 defer 中要对于各个子方法进行判断，到底是哪个方法有错误，然后逐一进行判定。相当于处理错误的逻辑集中放置到了最后一个函数进行执行了。</p><p>也就是说，将错误放置在对象本身的时候，通常应该为顺序调用的方法，一旦前者出现错误，后者即可退出</p><p>如果不是顺序的执行过程，那么有些的错误就可能被湮没，导致错误无法被感知。</p><h3 id="分层架构中的错误处理方法"><a href="#分层架构中的错误处理方法" class="headerlink" title="分层架构中的错误处理方法"></a>分层架构中的错误处理方法</h3><p>常见的分层架构</p><ul><li>controller 控制层</li><li>service 服务层</li><li>dao 数据访问层</li></ul><p>dao 层生产错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service 追加错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := a.Dao.getName()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;getname err: %w&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 打印错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pkg-errors"><a href="#pkg-errors" class="headerlink" title="pkg&#x2F;errors"></a>pkg&#x2F;errors</h3><p>如果感觉标准库提供的错误处理不够丰富，也可以使用 github.com&#x2F;pkg&#x2F;errors 来处理错误</p><p>此包常用的方法有</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成新的错误，同样会附加堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span><span class="type">error</span></span><br><span class="line"><span class="comment">// 只附加新的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err <span class="type">error</span>,message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"><span class="comment">// 只附加堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span><span class="type">error</span></span><br><span class="line"><span class="comment">// 附加信息 + 堆栈信息(就是一大堆的各种文件的堆栈调用过程的详细信息)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrapf</span><span class="params">(err <span class="type">error</span>,format <span class="type">string</span>,args...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"><span class="comment">// 获取最根本的错误（错误链的最底层）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := age()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// %+v 是 pkg/errors 包提供的格式化输出格式，输出错误堆栈</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用这个 pkg&#x2F;errors 包的时候要注意一件事，因为 wrap 可以包装堆栈向上输出，如果你调用的第三方库使用了 wrap，你再次使用 wrap，那么就会出现两堆相同的堆栈信息，这造成了极大的冗余。</p><p>所以，</p><ul><li>在提供多人使用的三方库的时候不要使用 wrap，只有逻辑代码的时候使用 wrap 的功能</li><li>遇到一个错误不打算处理，那么要带上足够多的信息再向上抛出</li><li>一旦错误处理完成之后就没有错误了，不再需要把错误继续网上抛，返回 nil 即可</li></ul><p>所以我们使用 pkg&#x2F;errors 包将上面的分层写法做一个更完善的改进：</p><p>dao 层生产错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span><span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 返回此处的错误堆栈</span></span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;error:&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service 追加错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err := a.getName()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 不返回堆栈了，仅仅添加错误</span></span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err,<span class="string">&quot;getName error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 打印错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 添加日志</span></span><br><span class="line">log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="errgroup-的使用技巧"><a href="#errgroup-的使用技巧" class="headerlink" title="errgroup 的使用技巧"></a>errgroup 的使用技巧</h3><p>errgroup 的使用方法是 golang.org&#x2F;x&#x2F;sync&#x2F;errgroup</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">g, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"><span class="comment">// 启动一个 goroutine去处理错误</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error1&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error2&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 类似 waitgroup 的 wait 方法</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理相关技巧"><a href="#错误处理相关技巧" class="headerlink" title="错误处理相关技巧"></a>错误处理相关技巧</h2><p>这里会介绍在实战过程中用到的诸多技巧</p><h3 id="使用-errors-New-时要写清楚包名"><a href="#使用-errors-New-时要写清楚包名" class="headerlink" title="使用 errors.New() 时要写清楚包名"></a>使用 errors.New() 时要写清楚包名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> age</span><br><span class="line"></span><br><span class="line">ErrMyAge := errors.New(<span class="string">&quot;age: ErrMyAge is error&quot;</span>)</span><br><span class="line">ErrMyAddress := errors.New(<span class="string">&quot;age: ErrMyAddress is error&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-error-处理一般错误，使用-panic-处理严重错误-异常"><a href="#使用-error-处理一般错误，使用-panic-处理严重错误-异常" class="headerlink" title="使用 error 处理一般错误，使用 panic 处理严重错误 (异常)"></a>使用 error 处理一般错误，使用 panic 处理严重错误 (异常)</h3><p>使用这种模型就避免了类似 Java 那种所有错误都一样的行为，Java 的使用 try-catch 的方式导致任何错误都是一个方式去处理，非常有可能让程序员忽略错误的处理</p><p>然而 go 不同，<strong>错误</strong>使用 error，<strong>异常</strong>使用 panic 的方式去处理。</p><ul><li>错误：error</li><li>异常：panic</li></ul><p>假设我们在代码中使用了 panic，通常来说，为了代码的健壮性还是会使用 defer 函数去运行一个 recover() 的，程序的存活比啥都重要。</p><h3 id="基础库，应该避免使用-error-types"><a href="#基础库，应该避免使用-error-types" class="headerlink" title="基础库，应该避免使用 error types"></a>基础库，应该避免使用 error types</h3><p>因为这种写法容易造成代码的耦合，尤其是在我们写的基础库中，非常容易造成改动代码来引入的不健壮性。</p><p>使用自定义的 error type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了额外增加更多的错误信息，字段需大写</span></span><br><span class="line"><span class="keyword">type</span> ErrMyAge <span class="keyword">struct</span> &#123;</span><br><span class="line">EV <span class="type">string</span></span><br><span class="line">MErr <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ErrMyAge)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;age: %s&quot;</span>, e.EV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := &amp;ErrMyAge&#123;<span class="string">&quot;err age is hi&quot;</span>&#125;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 errors.New() 哨兵错误模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我方代码</span></span><br><span class="line">ErrAge := errors.New(<span class="string">&quot;age: ErrAge is error&quot;</span>)</span><br><span class="line">ErrAddress := errors.New(<span class="string">&quot;age: ErrAddress is error&quot;</span>)</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;github.com/shgopher/age&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 带来了耦合</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, age.ErrAge)&#123;</span><br><span class="line"><span class="comment">// 处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上他们都是 error types，只不过前者比后者增加了很多额外的信息，但是相同点是，他们都造成了耦合</p><p>如果别人使用了这个基础库，那么势必这些错误就会跟使用者的代码耦合，我们改动了代码，第三方的代码就会因此受到影响。</p><p>因此，在对外暴露的基础包中，我们应尽量减少定义哨兵错误 (上述定义方法被称之为哨兵模式的错误)</p><p>上述提供的哨兵模式是透明的错误导出机制，所以容易造成耦合</p><p>我们可以提供不透明的机制，不导出透明的错误类型，仅仅让用户判断是否等于 nil，就可以防止耦合的存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">&quot;github.com/shgopher/age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err:= age.Bar(); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是大多数程序应该提供的模式，不对外暴露，避免了耦合</p><p>那么这种方法的缺陷也很明显了，就是无法获取更多的错误信息，理论上来说，我们也没必要获取那么多错误信息，但是如果真的要获取错误信息了，该如何去做呢？</p><p>我们可以向外暴露一些动作，只暴露行为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mage <span class="keyword">interface</span> &#123;</span><br><span class="line">age() <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个对外暴露的函数可以对外输出行为</span></span><br><span class="line"><span class="comment">// 并且还不用暴露出具体的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsMage</span><span class="params">(err <span class="type">error</span>)</span></span><span class="type">bool</span> &#123;</span><br><span class="line"> a, ok := err.(mage)</span><br><span class="line"> <span class="keyword">return</span> ok &amp;&amp; a.age()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化不必要的代码让程序变得更简洁"><a href="#优化不必要的代码让程序变得更简洁" class="headerlink" title="优化不必要的代码让程序变得更简洁"></a>优化不必要的代码让程序变得更简洁</h3><p>方法一将大函数变小函数，通过封装函数的方法从视觉上降低 if err 的影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造之前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(src ,dst <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r,err := os.Open(src); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> w,err := os.Create(dst); err != <span class="literal">nil</span> &#123;</span><br><span class="line">r.Cloase()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _,err := io.Copy(w,r); err!= <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面两个操作封装成一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenD</span><span class="params">(src dst <span class="type">string</span>)</span></span> (*os.File,*os.File,<span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> r ,w *os.File </span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r,err = os.Open(src); err!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> w,err = os.Create(dst); err!= <span class="literal">nil</span> &#123;</span><br><span class="line">r.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r,w,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数就只有一个 if err 了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(src,dst <span class="type">string</span>)</span></span><span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">var</span> r, w *os.File</span><br><span class="line"><span class="keyword">if</span> r,w,err = OpenD(src,dst); err!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">r.Close()</span><br><span class="line">w.Close()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> _,err = io.Copy(w,r); err!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二将代码中不必要的成分删除，来保证代码的简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthticateRequest</span><span class="params">(r *Request)</span></span><span class="type">error</span>&#123;</span><br><span class="line">err := authticate(r.User)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上 authticate 只返回一个 error 类型的接口，根本不需要判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthticateRequest</span><span class="params">(r *Request)</span></span><span class="type">error</span>&#123;</span><br><span class="line"><span class="keyword">return</span> authticate(r.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三使用更加合适的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要逐行去读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Countlines</span><span class="params">(r io.Reader)</span></span>(<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">br = bufio.NewReader(r)</span><br><span class="line">line <span class="type">int</span></span><br><span class="line">err <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_,err = br.readline(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">line ++ </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lines,<span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码看起来也是很合理的样子，也很简洁，但是，我们其实用的函数不是特别的合适</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实这里使用 scan 更加合适，代码量更加精简，并且结构异常舒服</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Countlines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">sc := bufio.NewScanner(r)</span><br><span class="line">lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">lines++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="错误应该只处理一次"><a href="#错误应该只处理一次" class="headerlink" title="错误应该只处理一次"></a>错误应该只处理一次</h3><p>我们有日志系统，有些时候我们发现一个错误，然后打了一个日志，然后又把错误给 return 了，实际上这与 go 语言哲学中说的错误只处理一次相违背</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span>&#123;</span><br><span class="line"> _, err := os.Open(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>  err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Prinln(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span>&#123;</span><br><span class="line"> _, err := os.Open(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>  err!= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的处理方法是错误只处理一次，那么在什么时候处理呢？</p><p>上文提到了多层的架构设计，我们在底层 (带有堆栈的错误向上抛出) 和中层 (仅仅附加信息再次向上抛出) 仅仅是向上抛出，并不需要将错误记录在日志中，在应用层才需要去使用日志记录错误，日志记录完错误以后，也不需要再向上抛出错误了 (最顶端了) 完全满足 “只处理一次错误” 的要求。</p><h2 id="业务-code-码的设置"><a href="#业务-code-码的设置" class="headerlink" title="业务 code 码的设置"></a>业务 code 码的设置</h2><p>常见的 http 错误码数量较少，比如常见的只有例如 404 301 302 200 503 等，绝对数量还是较少，无法去表达业务上的错误，因此我们需要设置一套能表达具体生产业务的 code 码。</p><p>为了保证服务端的安全，我们设置的 code 码应该设置两套数据，一套显示给客户端，一套自用，以此来保证服务端的绝对安全。</p><p>有三种设计业务 code 码的方式：</p><h3 id="一律返回-http-status-200，具体-code-码单独设置"><a href="#一律返回-http-status-200，具体-code-码单独设置" class="headerlink" title="一律返回 http status 200，具体 code 码单独设置"></a>一律返回 http status 200，具体 code 码单独设置</h3><p>例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Syntax error \&quot;Field picture specified more than once. This is only possible before version 2.1\&quot; at character 23: id,name,picture,picture&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OAuthException&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">2500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fbtrace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>http status code 通通 200</li><li>code 2500，才是真实的面向客户端的 code 码</li></ul><p>使用这种方法的一大缺陷就是必须解析 body 内容才能发现具体的错误业务码，很多场景我们仅仅需要知道返回的是成功或者错误，并不需要知晓具体的业务码，这是这种方式的一大弊端。</p><h3 id="使用合适的-http-status-code-简单的信息以及业务错误代码"><a href="#使用合适的-http-status-code-简单的信息以及业务错误代码" class="headerlink" title="使用合适的 http status code + 简单的信息以及业务错误代码"></a>使用合适的 http status code + 简单的信息以及业务错误代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">x-connection-hash: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">set-cookie: guest_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">Date: Thu, 01 Jun 2017 03:04:23 GMT</span><br><span class="line">Content-Length: 62</span><br><span class="line">x-response-time: 5</span><br><span class="line">strict-transport-security: max-age=631138519</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Server: tsa_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里：仅仅返回简单的错误信息</span></span><br><span class="line">&#123;<span class="string">&quot;errors&quot;</span>:[&#123;<span class="string">&quot;code&quot;</span>:215,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Bad Authentication data.&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这种方案也是大多数公司采纳的方案，使用具体的 http status code 可以知晓大概的业务类型，是错误还是正常运行，然后使用简单的错误信息和业务错误代码去定位具体的错误</p><p>如果业务不是特别复杂，使用这种方式即可</p><h3 id="使用合适的-http-status-code-非常详细的业务错误代码以及信息"><a href="#使用合适的-http-status-code-非常详细的业务错误代码以及信息" class="headerlink" title="使用合适的 http status code + 非常详细的业务错误代码以及信息"></a>使用合适的 http status code + 非常详细的业务错误代码以及信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400</span><br><span class="line">Date: Thu, 01 Jun 2017 03:40:55 GMT</span><br><span class="line">Content-Length: 276</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Server: Microsoft-IIS/10.0</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;SearchResponse&quot;</span>:&#123;<span class="string">&quot;Version&quot;</span>:<span class="string">&quot;2.2&quot;</span>,<span class="string">&quot;Query&quot;</span>:&#123;<span class="string">&quot;SearchTerms&quot;</span>:<span class="string">&quot;api error codes&quot;</span>&#125;,<span class="string">&quot;Errors&quot;</span>:[&#123;<span class="string">&quot;Code&quot;</span>:1001,<span class="string">&quot;Message&quot;</span>:<span class="string">&quot;Required parameter is missing.&quot;</span>,<span class="string">&quot;Parameter&quot;</span>:<span class="string">&quot;SearchRequest.AppId&quot;</span>,<span class="string">&quot;HelpUrl&quot;</span>:<span class="string">&quot;http\u003a\u002f\u002fmsdn.microsoft.com\u002fen-us\u002flibrary\u002fdd251042.aspx&quot;</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><p>当业务逻辑稍微复杂一些，并且需要极其精准和快速的定位错误时，就需要在返回的 body 中去设置非常详细的错误信息</p><p><strong>综上所述：</strong></p><ul><li>使用正确的 http status code 让业务的第一步变得更加直观</li><li>区别于 http status code，具体业务的 code 码会更加丰富</li><li>返回尽可能详细的错误，有助于复杂逻辑的快速错误定位</li><li>直接返回给客户的错误代码不应该包括敏感信息，敏感信息的 code 码仅供内部使用</li><li>错误信息要求规范，简洁以及有用</li></ul><h3 id="业务-code-码的具体设计"><a href="#业务-code-码的具体设计" class="headerlink" title="业务 code 码的具体设计"></a>业务 code 码的具体设计</h3><p>引入业务 code 码的核心原因就是 http status code 太少，以及他们并不能跟具体业务挂钩。</p><p>当我们设置好良好又详细的 code 码时，我们就可以快速定位业务代码，以及可以快速知晓发生错误的等级模块，具体信息等</p><p>下面给出具体的设计思路：<strong>纯数字表达，不同的数字段表达不同的模块不同的业务</strong></p><p>例如 100101</p><ul><li>10：表示某个服务</li><li>01：表示某个服务下的模块</li><li>01：模块下的错误码</li></ul><p>10 服务 01 模块 01 错误，— 服务 10 数据库模块未找到记录错误</p><p>一共最多有 100 个服务，每个服务最多有 100 个模块，每个模块最多有 100 个错误，如果某些模块 100 个都不够用，那怎么这个模块有必要去拆分一下了。</p><h3 id="如何设置-http-status-code"><a href="#如何设置-http-status-code" class="headerlink" title="如何设置 http status code"></a>如何设置 http status code</h3><ul><li><code>1xx</code>：请求已接收，继续处理</li><li><code>2xx</code>：成功处理了请求</li><li><code>3xx</code>：请求被重定向</li><li><code>4xx</code>：请求错误</li><li><code>5xx</code>：服务器错误</li></ul><p>由于 http status code 相对数量也不算太少，如果每一个都利用上，难免会增加复杂度，建议仅使用基本的几个即可</p><ul><li>200 - 表示请求成功执行。</li><li>400 - 表示客户端出问题。</li><li>500 - 表示服务端出问题。</li></ul><p>如果上述的感觉太少，再增加下面几个也可以</p><ul><li>401 - 表示认证失败。</li><li>403 - 表示授权失败。</li><li>404 - 表示资源找不到，这里的资源可以是 URL 或者 RESTful 资源。</li></ul><p>将 http status code 控制在<strong>个位数</strong>，有利于后端的逻辑代码简洁性，比如 301 302 确实是代表不同的含义，<strong>前端或许可以设置丰富的 http status code，因为浏览器会进行相关的具体操作，但是后端返回给前端的 http status code 并没有任何的操作，使用过多只会增加复杂度。</strong></p><h2 id="设计一个生产级的错误包"><a href="#设计一个生产级的错误包" class="headerlink" title="设计一个生产级的错误包"></a>设计一个生产级的错误包</h2><h3 id="生产级的错误包需要的功能"><a href="#生产级的错误包需要的功能" class="headerlink" title="生产级的错误包需要的功能"></a>生产级的错误包需要的功能</h3><ol><li>支持错误堆栈</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">02</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">03</span> call <span class="function"><span class="keyword">func</span> <span class="title">got</span> <span class="title">failed</span>: <span class="title">func</span> <span class="title">called</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">main.funcB /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">27</span></span><br><span class="line">main.funcA /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">19</span></span><br><span class="line">main.main /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main /home/colin/<span class="keyword">go</span>/go1<span class="number">.16</span><span class="number">.2</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">225</span>runtime.goexit /home/colin/<span class="keyword">go</span>/go1<span class="number">.16</span><span class="number">.2</span>/src/runtime/asm_amd64.s:<span class="number">1371</span></span><br><span class="line">exit status <span class="number">1</span></span><br></pre></td></tr></table></figure><p>拥有错误的堆栈，我们才能定位错误的根源。</p><ol start="2"><li><p>支持打印不同的格式比如 %s %w %d</p></li><li><p>支持 Wrap() Unwrap() 的功能，就是错误的嵌套和反嵌套</p></li><li><p>错误包要支持 Is() 和 As() 方法，这主要是因为有错误的嵌套，所以无法再使用接口相比较的方式进行判断接口类型是否相等 (类型相同，值相同)</p></li><li><p>要支持格式化和非格式化的创建方式</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">errors.New(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>从 github.com&#x2F;pkg&#x2F;errors 包中改造即可。</p><p>增加以下字段的结构体就可以满足上面的需求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> withCode <span class="keyword">struct</span> &#123;</span><br><span class="line">err   <span class="type">error</span></span><br><span class="line">code  <span class="type">int</span></span><br><span class="line">cause <span class="type">error</span></span><br><span class="line">*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="issues-1"><a href="#issues-1" class="headerlink" title="issues"></a>issues</h2><p><code>问题一：</code> <strong>请说出下列代码的执行输出</strong>*</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;hi1&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;oops&quot;</span>)</span><br><span class="line"><span class="comment">// 这里的defer将不会进栈，所以也就不会执行了。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;hi2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hi1</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">oops</span><br><span class="line"><span class="built_in">panic</span>: oops</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">/tmp/sandbox1932632082/prog.<span class="keyword">go</span>:<span class="number">18</span> +<span class="number">0xa7</span></span><br><span class="line"></span><br><span class="line">Program exited.</span><br></pre></td></tr></table></figure><p>解释：Panic，意味着恐慌，意思等于 return，所以 panic 下面的数据是无法执行的，defer 不同，他们是顺序的将这些 defer 函数装入函数内置的 defer 栈的，所以在 return 之后，defer 栈会执行，所以这里的 defer 1 2 3 可以执行，Panic 前面的 hi1 可以执行，但是 Panic 之后，相当于 return 后面的 hi2 就无法执行了。</p><p><code>问题二：</code> <strong>看一段代码，分析答案</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;starting f&quot;</span>)</span><br><span class="line">g(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;behind  g&quot;</span>) <span class="comment">//会终止执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i) <span class="comment">//终止执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">starting f</span><br><span class="line">panicking</span><br><span class="line"><span class="title class_">Defer</span> <span class="keyword">in</span> g <span class="number">2</span></span><br><span class="line">recoverd <span class="keyword">in</span> f</span><br></pre></td></tr></table></figure><p>解释一下，首先执行的是 f 函数的代码，然后开始执行 g，在 g 中遇到了 Panic，所以 panic 后面的 parinting in g 就无法执行了，所以执行了 defer in g<br>这个时候 f 中的 g(2) 后面的数据也无法执行了，因为整个 f 也陷入了恐慌，所以它只能 return 进入 defer 了，defer 中刚好有 recover，所以执行了 recover 信息后，就退出了函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 加强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论专区</title>
      <link href="/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/"/>
      <url>/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="赛博树洞"><a href="#赛博树洞" class="headerlink" title="赛博树洞"></a>赛博树洞</h1><h2 id="欢迎来到本博客最欢乐的角落！"><a href="#欢迎来到本博客最欢乐的角落！" class="headerlink" title="欢迎来到本博客最欢乐的角落！"></a>欢迎来到本博客最欢乐的角落！</h2><h2 id="无论你是技术大佬还是摆烂选手，都可以在这里畅所欲言，评论区等你开大！"><a href="#无论你是技术大佬还是摆烂选手，都可以在这里畅所欲言，评论区等你开大！" class="headerlink" title="无论你是技术大佬还是摆烂选手，都可以在这里畅所欲言，评论区等你开大！"></a>无论你是技术大佬还是摆烂选手，都可以在这里畅所欲言，评论区等你开大！</h2><h2 id="你的每一句评论，都是我继续摸鱼的动力！"><a href="#你的每一句评论，都是我继续摸鱼的动力！" class="headerlink" title="你的每一句评论，都是我继续摸鱼的动力！"></a>你的每一句评论，都是我继续摸鱼的动力！</h2><blockquote><p>今日节目单：评论 roll 鼠标垫！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 评论 </tag>
            
            <tag> roll </tag>
            
            <tag> 鼠标垫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验教训</title>
      <link href="/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/"/>
      <url>/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件扩展名大小写的影响总结"><a href="#1-文件扩展名大小写的影响总结" class="headerlink" title="1.文件扩展名大小写的影响总结"></a>1.文件扩展名大小写的影响总结</h2><p>在文件管理和 Web 开发中，文件扩展名的大小写可能会导致访问异常，尤其是在不同操作系统下表现不同。</p><h3 id="为什么大小写有影响？"><a href="#为什么大小写有影响？" class="headerlink" title="为什么大小写有影响？"></a>为什么大小写有影响？</h3><ul><li><p><strong>Windows 系统</strong><br>文件路径通常不区分大小写。例如，<code>image.jpg</code> 和 <code>image.JPG</code> 被视为同一个文件，因此本地预览时不会出现问题。</p></li><li><p><strong>Linux&#x2F;Unix 系统</strong><br>大多数 Web 服务器运行在 Linux 或 Unix 系统上，这些系统区分大小写。<code>image.jpg</code> 和 <code>image.JPG</code> 会被当作两个不同的文件。</p></li></ul><h3 id="常见问题举例"><a href="#常见问题举例" class="headerlink" title="常见问题举例"></a>常见问题举例</h3><p>如果配置文件中写的是 <code>/images/wechat.jpg</code>，但实际上传的文件名是 <code>wechat.JPG</code>，服务器会找不到 <code>wechat.jpg</code>，导致返回“404 Not Found”错误。</p><blockquote><p><strong>建议</strong>：在上传文件或编写路径时，统一使用小写扩展名，确保本地与服务器环境一致，避免因大小写问题导致资源无法访问。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go项目基础第一天</title>
      <link href="/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-随机数种子与版本变化总结"><a href="#Go-随机数种子与版本变化总结" class="headerlink" title="Go 随机数种子与版本变化总结"></a>Go 随机数种子与版本变化总结</h1><h2 id="随机数种子的作用"><a href="#随机数种子的作用" class="headerlink" title="随机数种子的作用"></a>随机数种子的作用</h2><ul><li>随机数种子（Random Seed）是伪随机数生成器的“起点”，决定了随机数序列的起始位置。</li><li>相同的种子会生成相同的随机数序列，不同的种子会生成不同的序列。</li><li>在 Go 语言中，未设置种子时，默认行为会影响每次运行的随机数结果。</li></ul><h2 id="Go-版本对随机数种子的影响"><a href="#Go-版本对随机数种子的影响" class="headerlink" title="Go 版本对随机数种子的影响"></a>Go 版本对随机数种子的影响</h2><table><thead><tr><th>Go 版本</th><th>随机数种子默认行为</th><th>结果表现</th><th>是否需要手动播种</th></tr></thead><tbody><tr><td>Go &lt; 1.20</td><td>默认种子为固定值（如 1）</td><td>每次运行结果都一样</td><td>需要手动设置种子</td></tr><tr><td>Go ≥ 1.20</td><td>自动使用系统随机源（如 &#x2F;dev&#x2F;urandom）</td><td>每次运行结果都不同</td><td>不需要手动设置种子</td></tr></tbody></table><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go &lt; 1.20 推荐手动播种</span></span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="built_in">println</span>(rand.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Go 1.20 及以后版本，math&#x2F;rand 包自动播种，使用起来更方便，无需手动设置种子即可获得不同的随机数序列。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第八天</title>
      <link href="/2025/09/10/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E5%A4%A9/"/>
      <url>/2025/09/10/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Go文件处理"><a href="#1-Go文件处理" class="headerlink" title="1.Go文件处理"></a>1.Go文件处理</h1><ul><li><strong>os</strong>：核心库，提供底层文件操作（创建、读写、删除等），大多数场景优先使用。</li><li><strong>io</strong>：提供通用接口（如 Reader&#x2F;Writer），可与文件、网络等数据源交互。</li><li><strong>bufio</strong>：通过缓冲优化性能，减少 I&#x2F;O 操作次数，适合频繁读写场景。</li><li><strong>ioutil</strong>：已弃用，Go 1.16 后相关功能已迁移到 os 和 io 包。</li><li><strong>path&#x2F;filepath</strong>：处理路径，跨平台兼容 Windows&#x2F;Unix 路径分隔符差异。</li></ul><blockquote><p>文件在创建、读取并赋值后要及时关闭，以免资源占用。</p></blockquote><h1 id="2-Go正则表达式使用注意事项"><a href="#2-Go正则表达式使用注意事项" class="headerlink" title="2.Go正则表达式使用注意事项"></a>2.Go正则表达式使用注意事项</h1><h2 id="常用正则表达式语法表"><a href="#常用正则表达式语法表" class="headerlink" title="常用正则表达式语法表"></a>常用正则表达式语法表</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除了换行符）</td></tr><tr><td><code>*</code></td><td>匹配前面的字符 0 次或多次</td></tr><tr><td><code>+</code></td><td>匹配前面的字符 1 次或多次</td></tr><tr><td><code>?</code></td><td>匹配前面的字符 0 次或 1 次</td></tr><tr><td><code>\d</code></td><td>匹配数字字符（等价于 <code>[0-9]</code>）</td></tr><tr><td><code>\w</code></td><td>匹配字母、数字或下划线（等价于 <code>[a-zA-Z0-9_]</code>）</td></tr><tr><td><code>\s</code></td><td>匹配空白字符（包括空格、制表符、换行符等）</td></tr><tr><td><code>[]</code></td><td>匹配括号内的任意一个字符（如 <code>[abc]</code> 匹配 a、b 或 c）</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头</td></tr><tr><td><code>$</code></td><td>匹配字符串</td></tr></tbody></table><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ul><li>正则表达式的匹配和替换操作可能会消耗较多资源，尤其是在处理大量数据时。</li><li>在性能敏感的场景下，建议谨慎使用正则表达式，必要时考虑优化或采用其他方案。</li></ul><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ul><li>在 Go 语言中，正则表达式中的反斜杠 <code>\</code> 需要写成 <code>\\</code>，因为反斜杠在字符串中也是转义字符。</li><li>示例：<code>\\d</code> 表示匹配数字字符。</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li>使用 <code>regexp.Compile</code> 或 <code>regexp.MustCompile</code> 函数时，务必检查返回的错误，以避免程序崩溃。</li><li>推荐做法：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re, err := regexp.Compile(pattern)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>合理使用正则表达式，注意性能和错误处理，能提升程序的健壮性和效率。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 文件处理和正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第七天</title>
      <link href="/2025/09/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
      <url>/2025/09/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？"><a href="#1-发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？" class="headerlink" title="1.发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？"></a>1.发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体对方法的调用</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">        Dividend <span class="type">int</span></span><br><span class="line">        Divisor  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DivideError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot divide %d by %d&quot;</span>, e.Dividend, e.Divisor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口对方法的调用</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">        Area() <span class="type">float64</span></span><br><span class="line">        Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.Radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-并发以及通道"><a href="#2-并发以及通道" class="headerlink" title="2.并发以及通道"></a>2.并发以及通道</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- i<span class="comment">//通道接收数据,不能加等号！！那是赋值语句</span></span><br><span class="line">c =&lt;- ch<span class="comment">//通道发送数据</span></span><br></pre></td></tr></table></figure><ul><li>Go 语言通过 Goroutine 和 Channel 实现高效并发，简化了传统线程模型。</li><li><strong>Goroutine</strong>：轻量级线程，使用 <code>go</code> 关键字启动。</li><li><strong>Channel</strong>：用于 Goroutine 之间的数据通信。</li><li><strong>Select 语句</strong>：可同时等待多个 Channel 操作，提升并发处理能力。</li></ul><h3 id="常见并发问题及解决方法"><a href="#常见并发问题及解决方法" class="headerlink" title="常见并发问题及解决方法"></a>常见并发问题及解决方法</h3><ul><li><strong>死锁（Deadlock）</strong>：所有 Goroutine 都在等待数据，程序无法继续。  <ul><li>解决：合理关闭通道，避免无限等待。</li><li>解决：使用 Mutex 或 Channel 进行同步，保证数据安全。</li></ul></li></ul><p><strong>总结</strong>：Go 并发编程简单高效，需注意死锁和数据竞争等问题，合理使用同步工具可提升程序性能和稳定性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 结构体和并发 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第六天</title>
      <link href="/2025/09/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
      <url>/2025/09/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-递归与迭代的对比总结"><a href="#1-递归与迭代的对比总结" class="headerlink" title="1.递归与迭代的对比总结"></a>1.递归与迭代的对比总结</h2><ul><li><p><strong>递归函数结构</strong><br>包含基准条件（终止递归）和递归条件（函数自身调用，分解问题）。</p></li><li><p><strong>优点</strong>  </p><ul><li>代码简洁，易于理解。</li><li>适合分解为相似子问题的问题，如树遍历、分治算法等。</li></ul></li><li><p><strong>缺点</strong>  </p><ul><li>性能开销较大，递归调用会占用栈空间，递归深度过大可能导致栈溢出。</li><li>调试较困难，递归层次多时不易定位问题。</li></ul></li><li><p><strong>递归与迭代对比</strong></p></li></ul><table><thead><tr><th>特性</th><th>递归</th><th>迭代</th></tr></thead><tbody><tr><td>代码简洁性</td><td>通常更简洁</td><td>可能更冗长</td></tr><tr><td>性能</td><td>可能较慢，占用栈空间</td><td>通常更快，占用较少内存</td></tr><tr><td>适用场景</td><td>适合分解为子问题的问题</td><td>适合线性或简单重复的问题</td></tr></tbody></table><p><strong>总结</strong>：递归适合解决可分解为子问题的复杂场景，代码简洁但有性能和调试上的劣势；迭代适合处理线性、重复性强的问题，性能更优但代码可能冗长。</p><h2 id="2-数值数据类型转换、字符串数据类型转换√"><a href="#2-数值数据类型转换、字符串数据类型转换√" class="headerlink" title="2.数值数据类型转换、字符串数据类型转换√"></a>2.数值数据类型转换、字符串数据类型转换√</h2><h2 id="3-接口类型转换有两种情况：类型断言和类型转换？（方法？）"><a href="#3-接口类型转换有两种情况：类型断言和类型转换？（方法？）" class="headerlink" title="3.接口类型转换有两种情况：类型断言和类型转换？（方法？）"></a>3.接口类型转换有两种情况：类型断言和类型转换？（方法？）</h2><p>1.定义接口、定义结构体；<br>2.结构体实现接口的所有方法；<br>3.结构体赋实例，再赋值给接口变量（数据类型为接口的变量）；<br>4.接口变量直接调用接口方法。</p><p><strong>接口类型变量可以存储任何实现了该接口的类型的值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义接口</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">        Area() <span class="type">float64</span></span><br><span class="line">        Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义结构体 Rectangle</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Long <span class="type">float64</span></span><br><span class="line">Short <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义结构体 Rectangle</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">        Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Rectangle 实现 Shape 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.Long * c.Short</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (c.Long + c.Short)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Circle 实现 Shape 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Pi * c.Radius * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s Shape<span class="comment">//接口类型变量可以存储任何实现了该接口的类型的值</span></span><br><span class="line">    <span class="number">4.</span>s= Rectangle&#123;Long: <span class="number">5</span>,Short:<span class="number">3</span>&#125;<span class="comment">//实现了该接口的类型的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;圆形：&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;面积为：&quot;</span>, s.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;周长为：&quot;</span>, s.Perimeter())</span><br><span class="line">s= Circle&#123;Radius: <span class="number">5</span>&#125;<span class="comment">//实现了该接口的类型的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;矩形：&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;面积为：&quot;</span>, s.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;周长为：&quot;</span>, s.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-next-错误处理"><a href="#4-next-错误处理" class="headerlink" title="4.next:错误处理"></a>4.next:错误处理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 递归迭代与接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第五天</title>
      <link href="/2025/09/06/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
      <url>/2025/09/06/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>学了array、slice（其实就是一个容量可变的array）、structure、range遍历各个数组和集合的用法、指针。</p><h1 id="1-Go切片默认容量扩展机制"><a href="#1-Go切片默认容量扩展机制" class="headerlink" title="1.Go切片默认容量扩展机制"></a>1.Go切片默认容量扩展机制</h1><p>在 Go 语言中，切片的容量扩展并不是简单的按需分配，而是结合了<strong>容量翻倍策略</strong>和<strong>内存分配器的大小等级取整</strong>机制。这样设计的目的是提升分配效率、减少内存碎片，并优化整体性能。</p><ul><li>Go 的运行时内存分配器会根据预定义的大小等级分配内存块，而不是每次都精确分配所需字节。</li><li>当切片容量不足时，append 操作会触发扩容，通常采用容量翻倍策略，但最终容量会向上取整到最近的大小等级。</li><li>例如，追加元素后所需容量为 5，但实际分配的容量为 6，因为 6 个 int 能刚好匹配 48 字节的分配等级。</li></ul><p>这种机制虽然可能导致单次分配时多分配一些内存，但能显著提升切片 append 操作的平均性能，减少频繁分配带来的性能损耗。<br>当然，容量也可以自定义！！</p><h2 id="操作过程举例"><a href="#操作过程举例" class="headerlink" title="操作过程举例"></a>操作过程举例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">/* 此时的默认扩容到了6而不是5（2+3） ！！！*/</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Map注意事项"><a href="#2-Map注意事项" class="headerlink" title="2.Map注意事项"></a>2.Map注意事项</h1><p>Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。</p><h1 id="3-指针的易错点"><a href="#3-指针的易错点" class="headerlink" title="3.指针的易错点"></a>3.指针的易错点</h1><p>使用指针所指内容之前，必须先给初始化指针（地址），即有了地址才能找内容，否则为空指针！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>channel的定义和用法？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 切片、集合和指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第四天</title>
      <link href="/2025/09/05/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
      <url>/2025/09/05/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">动词</th><th align="left">含义</th><th align="left">示例（整数255）</th><th align="left">示例（浮点数3.14159）</th></tr></thead><tbody><tr><td align="left"><code>%d</code></td><td align="left"><strong>十进制</strong>表示</td><td align="left"><code>255</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%x</code></td><td align="left"><strong>十六进制</strong>表示，使用<strong>小写</strong>字母 <code>a-f</code></td><td align="left"><code>ff</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%X</code></td><td align="left"><strong>十六进制</strong>表示，使用<strong>大写</strong>字母 <code>A-F</code></td><td align="left"><code>FF</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%p</code></td><td align="left"><strong>专用于打印指针（内存地址）</strong>。以十六进制输出，并加上前缀 <code>0x</code>（推荐方式）</td><td align="left"><code>0xff</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%o</code></td><td align="left"><strong>八进制</strong>表示</td><td align="left"><code>377</code></td><td align="left">不适用</td></tr><tr><td align="left"><code>%f</code></td><td align="left"><strong>浮点数十进制</strong>表示，默认6位小数</td><td align="left">不适用</td><td align="left"><code>3.141593</code></td></tr><tr><td align="left"><code>%g</code></td><td align="left"><strong>自动选择</strong> <code>%e</code> 或 <code>%f</code> 格式，产生更紧凑的输出</td><td align="left">不适用</td><td align="left"><code>3.14159</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 输出格式符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第三天</title>
      <link href="/2025/09/04/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2025/09/04/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><ul><li><strong>局部变量</strong>：在函数体内声明的变量称为局部变量，其作用域仅限于函数体内部。函数的参数和返回值变量也属于局部变量。</li><li><strong>全局变量</strong>：在函数体外声明的变量称为全局变量，全局变量可以在整个包内，甚至被导出后在外部包中使用。</li><li><strong>使用指针变量与不使用的区别</strong>：指针变量*（地址）的值会跟随变量的变化而变化，对比：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> ptr <span class="type">int</span></span><br><span class="line">    ptr = a </span><br><span class="line">    fmt.Println(ptr)<span class="comment">//4</span></span><br><span class="line">    a = <span class="number">15</span></span><br><span class="line">    fmt.Println(ptr)<span class="comment">//4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span> </span><br><span class="line">    <span class="keyword">var</span> ptr1 *<span class="type">int</span></span><br><span class="line">    ptr1 = &amp;b </span><br><span class="line">    fmt.Println(*ptr1)<span class="comment">//5</span></span><br><span class="line">    b=<span class="number">15</span> </span><br><span class="line">    fmt.Println(*ptr1)<span class="comment">//15 *ptr1的值跟随b的变化而变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注：</strong></p><ol><li>局部变量的生命周期仅在函数调用期间，函数调用结束后局部变量会被销毁。</li><li>Go 语言中，全局变量与局部变量可以同名，但在函数内部会优先使用局部变量。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 变量以及作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第二天</title>
      <link href="/2025/09/03/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2025/09/03/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言学习笔记"><a href="#Go语言学习笔记" class="headerlink" title="Go语言学习笔记"></a>Go语言学习笔记</h2><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ul><li>当标识符（包括常量、变量、类型、函数名、结构字段等）以<strong>大写字母</strong>开头时，如 <code>Group1</code>，该标识符可以被外部包的代码访问（需先导入该包），称为“导出”（类似于面向对象语言中的 <code>public</code>）。</li><li>如果标识符以<strong>小写字母</strong>开头，则对包外不可见，但在包内部可见并可用（类似于面向对象语言中的 <code>protected</code>）。</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul><li>运行 Go 文件：<code>go run hello.go</code></li><li>编译 Go 文件（生成可执行文件）：<code>go build hello.go</code></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>&#123;</code> 不能单独放在一行。</li><li><strong>文件名与包名</strong>没有直接关系，不要求一致。</li><li>同一文件夹下的所有文件<strong>只能有一个包名</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 标识符和常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习第一天</title>
      <link href="/2025/09/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2025/09/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="先在官网下载配置了go，然后配环境变量"><a href="#先在官网下载配置了go，然后配环境变量" class="headerlink" title="先在官网下载配置了go，然后配环境变量"></a>先在官网下载配置了go，然后配环境变量</h2><h2 id="又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏"><a href="#又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏" class="headerlink" title="又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏"></a>又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏</h2><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h2 id="1-package-main只能有一个"><a href="#1-package-main只能有一个" class="headerlink" title="1.package main只能有一个"></a>1.package main只能有一个</h2><h2 id="2-感觉包、库管理很像python，而语法和结构又像C"><a href="#2-感觉包、库管理很像python，而语法和结构又像C" class="headerlink" title="2.感觉包、库管理很像python，而语法和结构又像C"></a>2.感觉包、库管理很像python，而语法和结构又像C</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意事项</title>
      <link href="/2025/08/26/%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2025/08/26/%E5%9B%BE%E7%89%87%E9%85%8D%E7%BD%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="图片配置注意事项"><a href="#图片配置注意事项" class="headerlink" title="图片配置注意事项"></a>图片配置注意事项</h1><h2 id="图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号-！！）"><a href="#图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号-！！）" class="headerlink" title="图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号~！！）"></a>图片配置分为在线图片和本地图片，在线图片可以通过在线链接或者本地图片放到图床中再引用；本地图片放到source文件夹下的img文件夹中引用（要加双引号~！！）</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly的安装和配置</title>
      <link href="/2025/08/25/butterfly%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/08/25/butterfly%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><h3 id="在你的-Hexo-根目录"><a href="#在你的-Hexo-根目录" class="headerlink" title="在你的 Hexo 根目录"></a>在你的 Hexo 根目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h3 id="升級方法：在-Hexo-根目录下，运行"><a href="#升級方法：在-Hexo-根目录下，运行" class="headerlink" title="升級方法：在 Hexo 根目录下，运行"></a>升級方法：在 Hexo 根目录下，运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><h3 id="修改-Hexo-根目錄下的-config-yml，把主題改為-butterfly"><a href="#修改-Hexo-根目錄下的-config-yml，把主題改為-butterfly" class="headerlink" title="修改 Hexo 根目錄下的 _config.yml，把主題改為 butterfly"></a>修改 Hexo 根目錄下的 _config.yml，把主題改為 butterfly</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="如果你沒有-pug-以及-stylus-的渲染器，請下載安裝："><a href="#如果你沒有-pug-以及-stylus-的渲染器，請下載安裝：" class="headerlink" title="如果你沒有 pug 以及 stylus 的渲染器，請下載安裝："></a>如果你沒有 pug 以及 stylus 的渲染器，請下載安裝：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的配置和初始化</title>
      <link href="/2025/08/25/hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2025/08/25/hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0-首先安装好node-js和git（安装基础环境）"><a href="#0-首先安装好node-js和git（安装基础环境）" class="headerlink" title="0.首先安装好node.js和git（安装基础环境）"></a>0.首先安装好node.js和git（安装基础环境）</h2><h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="安装hexo依赖"><a href="#安装hexo依赖" class="headerlink" title="安装hexo依赖"></a>安装hexo依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="2-现在就可以通过hexo命令预览初创hexo网站了！"><a href="#2-现在就可以通过hexo命令预览初创hexo网站了！" class="headerlink" title="2.现在就可以通过hexo命令预览初创hexo网站了！"></a>2.现在就可以通过hexo命令预览初创hexo网站了！</h2><h3 id="清除hexo缓存"><a href="#清除hexo缓存" class="headerlink" title="清除hexo缓存"></a>清除hexo缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br></pre></td></tr></table></figure><h3 id="构建hexo"><a href="#构建hexo" class="headerlink" title="构建hexo"></a>构建hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="本地预览hexo"><a href="#本地预览hexo" class="headerlink" title="本地预览hexo"></a>本地预览hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="上传hexo"><a href="#上传hexo" class="headerlink" title="上传hexo"></a>上传hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/08/25/hello-world/"/>
      <url>/2025/08/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 梦开始的地方 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
