<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>加强学习第一天（四节） | Feynman</title><meta name="author" content="feynman"><meta name="copyright" content="feynman"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.变量声明变量声明符号 var 和 :&#x3D;在 go 语言中，我们使用 var 来表示声明一个变量 1var a string &#x3D; &quot;hello world&quot; 这就是一个标准的变量声明方式，var 符号在最前面，接着就是变量 a，变量后面紧跟着是变量的类型，这里是 string 类型，也就是字符串类型，&#x3D; 后面是要赋值的具体值 我们也可以直接声明不赋予初始值，go 语言默认，声明">
<meta property="og:type" content="article">
<meta property="og:title" content="加强学习第一天（四节）">
<meta property="og:url" content="http://example.com/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/index.html">
<meta property="og:site_name" content="Feynman">
<meta property="og:description" content="1.变量声明变量声明符号 var 和 :&#x3D;在 go 语言中，我们使用 var 来表示声明一个变量 1var a string &#x3D; &quot;hello world&quot; 这就是一个标准的变量声明方式，var 符号在最前面，接着就是变量 a，变量后面紧跟着是变量的类型，这里是 string 类型，也就是字符串类型，&#x3D; 后面是要赋值的具体值 我们也可以直接声明不赋予初始值，go 语言默认，声明">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/aiguo.jpeg">
<meta property="article:published_time" content="2025-09-17T08:26:38.000Z">
<meta property="article:modified_time" content="2025-09-17T08:30:19.942Z">
<meta property="article:author" content="feynman">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="加强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/aiguo.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "加强学习第一天（四节）",
  "url": "http://example.com/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/",
  "image": "http://example.com/img/aiguo.jpeg",
  "datePublished": "2025-09-17T08:26:38.000Z",
  "dateModified": "2025-09-17T08:30:19.942Z",
  "author": [
    {
      "@type": "Person",
      "name": "feynman",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: feynman","link":"链接: ","source":"来源: Feynman","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '加强学习第一天（四节）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/./img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas faf-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/./img/aiguo.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Feynman</span></a><a class="nav-page-title" href="/"><span class="site-name">加强学习第一天（四节）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas faf-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">加强学习第一天（四节）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T08:26:38.000Z" title="发表于 2025-09-17 16:26:38">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T08:30:19.942Z" title="更新于 2025-09-17 16:30:19">2025-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章创建于&quot;,&quot;messageNext&quot;:&quot;天前，请以最新文章为主.&quot;,&quot;postUpdate&quot;:&quot;2025-09-17 16:30:19&quot;}" hidden></div><h1 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h1><h2 id="变量声明符号-var-和"><a href="#变量声明符号-var-和" class="headerlink" title="变量声明符号 var 和 :="></a>变量声明符号 <code>var</code> 和 <code>:=</code></h2><p>在 go 语言中，我们使用 <code>var</code> 来表示声明一个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>这就是一个标准的变量声明方式，var 符号在最前面，接着就是变量 a，变量后面紧跟着是变量的类型，这里是 string 类型，也就是字符串类型，<code>=</code> 后面是要赋值的具体值</p>
<p>我们也可以直接声明不赋予初始值，go 语言默认，声明即赋予初始值，那么这里的字符串类型初始值就是一个空字符串 <code>&quot;&quot;</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>go 语言具有类型推断能力，所以我们可以省略类型，让 go 语言的编译器去推断类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>编译器会自动推断 a 为 string 类型</p>
<p>在函数体内部 (这是一个先决条件) 我们<strong>也</strong>可以使用省略的写法，就是使用一个符号 <code>:=</code> 来充当 <code>var</code> 的角色，也就是初始化的工作，比如说</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个的用法是 <code>[变量] [:=] [初始值]</code> 这三者缺一不可，而且还不能多，不能在 a 后面带有类型，不能省略初始值，且仅限于函数&#x2F;方法内部使用</p>
<p>go 语言支持多变量同时赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">string</span> = <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">a, b := <span class="string">&quot;hello world&quot;</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>其中，使用 var 进行声明的时候，如果是多个变量同时声明，必须是相同类型；使用 <code>:= </code> 进行多变量赋值时，多个变量可以不同类型，因为全靠编译器推断</p>
<h2 id="常见的变量声明方式"><a href="#常见的变量声明方式" class="headerlink" title="常见的变量声明方式"></a>常见的变量声明方式</h2><p>从广义上来说，go 语言只有两种变量，包一级的变量和函数一级的变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultValue <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMethod</span><span class="params">(n <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>DefaultValue</code> 就是包级变量，<code>n</code> 就是函数级变量 (也是形式变量)</p>
<p>下面我列举一些常见的声明方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> a <span class="type">string</span></span><br><span class="line"> b <span class="type">int32</span> = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">//包级变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">  d := <span class="number">12</span> <span class="comment">//仅限函数内部使用，变量后面不能有类型</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">// 函数级变量</span></span><br><span class="line">  <span class="keyword">var</span> e = <span class="string">&quot;hello world&quot;</span> <span class="comment">//自动推断变量类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以说声明的方式很多，不过呢，在一个项目中应该尽量保证声明方式的一致性，因为可以加强代码的统一性，减少理解代码的难度。</p>
<h2 id="go-语言可导出变量"><a href="#go-语言可导出变量" class="headerlink" title="go 语言可导出变量"></a>go 语言可导出变量</h2><p>go 语言跟一般的语言不同，它使用变量<strong>首</strong>字母的大小写来区分变量的可导出性质，大写 (如果使用中文作为变量名称，默认是可导出的) 代表可导出，小写代表仅限包内部使用 (包这一级，多个文件只要是同一个包就可以使用)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Example</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OutPutName = <span class="number">0o77</span></span><br><span class="line"><span class="keyword">var</span> inName = <span class="number">0x99</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>OutPutName</code> 是一个可导出的变量，<code>inName</code> 是不可导出变量</p>
<p>go 语言还拥有比如函数，方法，结构体，接口，等等各类型的组件，这里你可以先不懂到底是什么，你先有一个印象，但凡首字母是大写的都是可以导出的，小写就是包内使用，没错，go 语言就是这么简单</p>
<h2 id="包级变量"><a href="#包级变量" class="headerlink" title="包级变量"></a>包级变量</h2><p><code>第一种声明形式</code>：<strong>声明的同时，显式初始化</strong></p>
<ul>
<li><code>var a = method(&quot;t&quot;)</code> go 编译器根据右侧的返回值自动确定左侧变量的类型</li>
<li><code>var a = 3.14</code> 在没有具体返回值，没有具体类型的情况下，go 赋予它默认类型，比如 float 的默认类型就是 float64，int 类型的默认类型就是 int</li>
<li>如果要显式的赋予类型，并且保证命名的一致性 <code>var a int = 12</code> 的行为应该避免，应该写成 <code>var a = int(12)</code> 用来保证一致性<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  a = <span class="number">3.14</span></span><br><span class="line">  b = <span class="type">int</span>(<span class="number">12</span>)</span><br><span class="line">  e = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>第二种声明形式</code>：<strong>声明但是延迟初始化</strong></p>
<p>只有 <code>var a int64</code> 这一种方式，不过呢，go 语言的声明是直接赋予零值的，比如说这里的 a 默认就是 <code>0</code></p>
<p>go 语言变量声明的聚集和就近原则：将同一类型的放在一个 var() 内部；或者另一种分类方法：将有初始值的放在一个 var 里，将延迟初始化的放在另一个 var 里。</p>
<p>分类一</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">int</span></span><br><span class="line">c <span class="type">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">d <span class="type">string</span></span><br><span class="line">e <span class="type">string</span></span><br><span class="line">f <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>分类二</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  a = <span class="number">12</span></span><br><span class="line">  b = <span class="string">&quot;string&quot;</span></span><br><span class="line">  c = <span class="string">&quot;string&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">  d <span class="type">int</span></span><br><span class="line">  c <span class="type">string</span></span><br><span class="line">  f <span class="type">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>接下来谈一谈就近原则，变量的声明和变量的使用尽量的近，不要都声明在头部，如果一个变量被全局大量使用，那么可以放在头部，如果就是仅仅使用少量的次数，还是应该在使用的前面就进进行声明</p>
<h2 id="函数级变量"><a href="#函数级变量" class="headerlink" title="函数级变量"></a>函数级变量</h2><p><code>第一种声明形式</code>：<strong>延迟初始化</strong></p>
<p>在函数体内使用 var</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量特别多，也可以使用 <code>var()</code> 的方法在函数内部使用</p>
<p><code>第二种声明形式</code>：<strong>声明且显式初始化的局部变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="number">12</span></span><br><span class="line">  b := <span class="type">int32</span>(<span class="number">20</span>) <span class="comment">// 改变默认类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小心-shadow-的变量"><a href="#小心-shadow-的变量" class="headerlink" title="小心 shadow 的变量"></a>小心 shadow 的变量</h2><p>我们知道，当有两个两个以上的变量在赋值时，如果其中有一个未被提前声明，那么就需要使用 <code>:=</code>，这个时候系统会自动判断有哪些未提前声明，然而有一种场景下系统会发生误判，准确的来说这是一种歧义，系统的判断会跟程序员的心理不一致，出现了变量 shadow 的行为，让我们看一下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    a,err := example.Method()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a,err := example.Method1()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在外层，a 已经提前声明，但是在 if 这个作用域中，由于 err 并未提前声明，所以使用了 <code>:=</code>，由于系统<strong>无法获知</strong>这里的 a 是否需要再次声明，所以 go 语言默认 a 是一个新的变量，这样外层的 a 就无法得到新的值，外层 a 也就被内层的 a 给 shadow 了。</p>
<p>如果想改变这种 bug，我们可以将 err 也提前声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    a,err = example.Method()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a,err = example.Method1()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者也可以改变内部的变量名称，来改变这种 shadow：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">  <span class="comment">// tracing 为 bool 类型</span></span><br><span class="line">  <span class="keyword">if</span> tracing&#123;</span><br><span class="line">    ai,err := example.Method()</span><br><span class="line">    a = ai</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ai,err := example.Method1()</span><br><span class="line">    a = ai</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-go-语言常量"><a href="#2-go-语言常量" class="headerlink" title="2.go 语言常量"></a>2.go 语言常量</h1><p>go 使用 const 来声明常量，常量表达式的运算在编译期就可以完成了，并且 go 常量是类型安全的，编译器优化友好的元素。</p>
<p>常量中的数据类型只可以是布尔、数字 (整数、浮点和复数) 以及字符串型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  startOne = <span class="number">-2</span></span><br><span class="line">  startTwo = <span class="number">1.0</span></span><br><span class="line">  startThree = <span class="number">3.14</span></span><br><span class="line">  isTrue = <span class="literal">true</span></span><br><span class="line">  hi = <span class="string">&quot;hi&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>go 推崇无类型常量，这主要是因为 go 不支持隐式的类型转化，只能显式转换，所以一旦常量给定类型，那么它跟变量之间或许就要将常量转化类型才能进行运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PI = <span class="number">3.14</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = PI</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">float64</span> = PI</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，如果是没有类型的常量，可以非常灵活的赋予 float32 或者 float64 都可以。</p>
<h2 id="局部常量"><a href="#局部常量" class="headerlink" title="局部常量"></a>局部常量</h2><p>在 Go 中，局部常量在编译期常量折叠 (compile-time constant folding) 时会被编译器处理成字面值，因此局部常量在编译时会被编译。</p>
<p>例如，下面的代码定义了一个局部常量 x，并使用它来初始化一个变量 y：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">42</span></span><br><span class="line">    <span class="keyword">var</span> y = x * <span class="number">2</span></span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译时，x 将被处理成字面值 42，因此编译器将 y 初始化为 84，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">84</span></span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，局部常量在编译期已经被折叠成了字面值，因此在运行时不会再进行计算了。</p>
<h2 id="常量不可包含计算"><a href="#常量不可包含计算" class="headerlink" title="常量不可包含计算"></a>常量不可包含计算</h2><p>在 Go 中，常量必须在编译时就可以确定其值。因此，常量的值必须是一个编译时的常量表达式，不能包含运行时的计算。</p>
<p>不过，常量表达式可以包含一些简单的运算，例如加、减、乘、除、取模等算术运算，以及位运算、逻辑运算等。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="number">2</span> + <span class="number">3</span>            <span class="comment">// 常量表达式，结果为 5</span></span><br><span class="line">    y = (x * <span class="number">2</span>) % <span class="number">10</span>     <span class="comment">// 常量表达式，结果为 0</span></span><br><span class="line">    z = x == <span class="number">5</span> || y == <span class="number">0</span> <span class="comment">// 常量表达式，结果为 true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量表达式还可以使用一些内置函数，例如 <code>len</code>、<code>cap</code>、<code>make</code>、<code>new</code> 等，以及可以在编译期计算的一些标准库函数，例如 <code>math.Sin</code>、<code>math.Pi</code> 等。</p>
<p>总之，常量必须在编译期就可以确定其值，因此不能包含运行时的计算，但可以包含一些简单的算术、位运算、逻辑运算等。</p>
<h2 id="枚举常量-iota"><a href="#枚举常量-iota" class="headerlink" title="枚举常量 iota"></a>枚举常量 iota</h2><p>go 语言提供隐式重复前一个非空表达式的机制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PI = <span class="number">3.14</span></span><br><span class="line">	a</span><br><span class="line">	b</span><br><span class="line">	c</span><br><span class="line">	d</span><br><span class="line">	e</span><br><span class="line">	f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(PI, a, b, c, d, e, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将会全部输出 3.14</p>
<p>iota 是 go 语言的一个预定义标识符，它表示 const 声明块中，每一个常量所处位置的偏移量，它本身也是一个无类型的常量，它的初始值是 0，意思是说此处的 iota 跟第一行比偏移了 0 个位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  f</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>同一行的常量 iota 值是一样的，可以理解为偏移量相同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a,b = <span class="literal">iota</span></span><br><span class="line">  c,d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果要让 iota 的初始值是 1，那么可以这么做</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  _ = <span class="literal">iota</span></span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>iota 只需要在一个 const 群中出现一次即可，出现多次跟出现一次的效果一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b = <span class="literal">iota</span></span><br><span class="line">  c = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 一样</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当 iota 群中出现异类该如何处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a = <span class="literal">iota</span></span><br><span class="line">  b = <span class="number">12</span></span><br><span class="line">  c = <span class="literal">iota</span></span><br><span class="line">  d</span><br><span class="line">  e</span><br><span class="line">  f</span><br><span class="line">  g</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>答案就是异类输出自己的，其它的常量不受影响，比如这里的输出就是 <code>0 12 2 3 4 5 6</code>，只要记住 iota 是偏移位置就可以理解为什么是这么输出的了。</p>
<p>如果不考虑常量的灵活性，极致追求安全性，那么也可以给 iota 常量加上类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  a <span class="type">int</span> = <span class="literal">iota</span></span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这种就要求变量类型必须是 int 才能被这些枚举类型接纳，但是一般常量还是用无类型的较为常见。</p>
<h1 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3.泛型"></a>3.泛型</h1><p><strong>导读：</strong></p>
<ul>
<li>约束</li>
<li>使用方法</li>
<li>实现原理</li>
<li>跟其它语言的泛型进行对比</li>
<li>用例子学泛型</li>
<li>issues</li>
</ul>
<blockquote>
<p>泛型需满足 <code>go1.18+</code></p>
</blockquote>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>go 使用 interface 作为约束，约束的意思是约束了这个泛型都具有哪些实际类型。所以可以理解为，go 将 interface 的职责给扩展了，让接口不仅仅作为接口 — 解耦的，抽象化的结构体，还具有了约束，对于类型的约束作用。</p>
<p>go 可以将所有的接口 (包括经典接口，和泛型以后的接口) 都用作约束，但是可以不代表应该，要有选择的去使用约束，但是约束并不是都可以作为传统的接口来使用的，例如传统的接口只能存在方法，并不能存在类型，<strong>只要存在类型就自动归纳为约束</strong></p>
<p>综上所述，第一，约束的概念大于接口，只有传统接口可以作为抽象类型去使用，约束只能存在于函数方法或者类型之中，不能单独使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a1 a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a <span class="keyword">interface</span>&#123;</span><br><span class="line">	<span class="type">int</span>|<span class="type">float64</span></span><br><span class="line">	get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不能在类型约束之外使用类型 a：接口包含类型约束</span></span><br><span class="line">cannot use <span class="built_in">type</span> a outside a <span class="built_in">type</span> constraint: interface contains <span class="built_in">type</span> constraints</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二，不要把传统接口用在约束的地方，这种用法是不合适的，通常来说传统接口的模式就用作抽象类型的解耦即可 (用了也不错，只是不建议)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	hi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span>[<span class="title">T</span> <span class="title">Writer</span>]<span class="params">(v T)</span></span> &#123;</span><br><span class="line">	v.hi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型是类型，约束是类型的约束"><a href="#泛型是类型，约束是类型的约束" class="headerlink" title="泛型是类型，约束是类型的约束"></a>泛型是类型，约束是类型的约束</h3><p>请认识到，泛型是一种类型，约束是一种类型的约束，请不要把约束当作泛型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="type">int</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 st 约束拥有 int 和 string，请注意这里的 st 是约束，不是泛型类型</p>
<p>go 内置了很多约束，比如说 any 和 comparable，意思是任何类型和可以比较的类型。以后<em><strong>应该</strong></em>会有一个新的内置约束的包叫做 <code>package constraints</code> 例如 any comparable，Ordered 等等约束都会内置到标准库中</p>
<p>约束不仅仅可以单独写出来，还可以内置于函数内部。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">int</span>| <span class="title">string</span>, <span class="title">B</span> <span class="title">float64</span>| <span class="title">string</span>]<span class="params">(i T,j B)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这种形式下，T 和 B 的约束就是仅限此函数使用</p>
<p>下面我们看一种形式，这种情况下约束的不仅仅是 string 和 int，而是包含了底层是他们的所有数据，比如说 <code>type DD int</code> 也符合这个约束，请记住只能使用在底层类型上，如果使用 <code>~DD</code> 是不被允许的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span>&#123;</span><br><span class="line">	~<span class="type">string</span> | ~<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约束的嵌套"><a href="#约束的嵌套" class="headerlink" title="约束的嵌套"></a>约束的嵌套</h3><p>约束跟接口是一样的也是可以嵌套的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ComparableHasher <span class="keyword">interface</span> &#123;</span><br><span class="line">	comparable</span><br><span class="line">	Hash() <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ImpossibleConstraint <span class="keyword">interface</span> &#123;</span><br><span class="line">	comparable</span><br><span class="line">	[]<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的意义就是 <strong>and</strong> 的意思就是说这个约束是可以比较的还是必须得支持 <code>hash()uintptr</code></p>
<p>下面这种方式也是可以的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumericAbs[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">		~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">		~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">		~<span class="type">complex64</span> | ~<span class="type">complex128</span></span><br><span class="line">	Abs() T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的类型意思是满足数字类型，下面的意思是满足这个方法，所以最终实现这个约束的对象就是一个数字类型，并且实现了这个接口的 <code>Abs()T</code> 方法。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>当结构体中使用泛型的时候，泛型不能直接作为嵌入使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lockable[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	T <span class="comment">// 正确的方法应该是 t T ； 将 T 作为类型参数，不可直接嵌入</span></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>错误提示：<code>embedded field type cannot be a (pointer to a) type parameter</code>；<code>嵌入式字段类型不能是（指向）类型参数</code></p>
<p>我们再看一下当泛型结构体嵌入到其它结构体中如何使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	T T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这里使用 A[T] 输入了实际类型，</span></span><br><span class="line">	A[T]</span><br><span class="line">	T T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出关键点，泛型结构体被嵌入其它结构体的时候，泛型要给实际的类型才可以</p>
<p>结构体泛型和方法中的泛型做对比：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a A[T])</span></span>Get()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>方法里的泛型是可以直接从 struct 定义的地方继承这个泛型 T 的，当这个结构体使用时，指定实际的类型即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d1 d</span><br><span class="line">	<span class="keyword">var</span> a  = A[d]&#123;</span><br><span class="line">		d1,</span><br><span class="line">	&#125;</span><br><span class="line">	a.Get()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要没有类型就不是约束，是接口，在go语言中，接口可以充当一个一般类型</span></span><br><span class="line"><span class="keyword">type</span> d <span class="keyword">interface</span> &#123;</span><br><span class="line">	get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	T T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A[T])</span></span> Get() &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>约束里的泛型同样不能直接嵌入使用</strong></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="keyword">type</span> B[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误提示：<code>cannot embed a type parameter</code></p>
<p>泛型只能充当类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EmbeddedParameter[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">uint</span> </span><br><span class="line">	me() T </span><br></pre></td></tr></table></figure>
<p>使用约束中的泛型还是需要注意一下的，稍微有些复杂：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">EmbeddedParameter</span>[<span class="title">T</span>]]<span class="params">(t T)</span></span>T&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下，中括号里面泛型的两个 T 表达的意思是不一样的，后面的 T 表达的是<strong>约束里的泛型</strong>，表示 any，前面的 T 表示的是满足后面的这个约束的类型 T，但是这里注意，后面 T 虽然之前定义的时候是 any 但是这里被赋予为 T 之后，改变了，改变为了必须满足约束 <code>EmbeddedParameter</code> 的类型，如果说的通俗点，从 any 变成了，满足 <code>int ｜ uint and 实现 me()T方法 </code> 后文会有代码进行解释。</p>
<p>当然了，后面的 T 没有也行，如果没有后面的 T 就是相当于不改变后面的 T 的约束类型了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Differ[T1 any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Diff(T1) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClose</span>[<span class="title">T2</span> <span class="title">Differ</span>]<span class="params">(a, b T2)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.Diff(b) &lt; <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当使用了泛型之后，是无法使用断言的，这是非法的，那么如果一定要在运行时的时候去判断类型怎么办呢？答案就是转变成 <code>any</code> (type any &#x3D; interface {}) 即可，因为我们知道任何对象都已经实现了空接口，那么就可以被空接口去转化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GeneralAbsDifference</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">switch</span> any(a).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>, <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span>, <span class="type">int64</span>,</span><br><span class="line">		<span class="type">uint</span>, <span class="type">uint8</span>, <span class="type">uint16</span>, <span class="type">uint32</span>, <span class="type">uint64</span>, <span class="type">uintptr</span>,</span><br><span class="line">		<span class="type">float32</span>, <span class="type">float64</span>:</span><br><span class="line">		<span class="keyword">return</span> OrderedAbsDifference(a, b) </span><br><span class="line">	<span class="keyword">case</span> <span class="type">complex64</span>, <span class="type">complex128</span>:</span><br><span class="line">		<span class="keyword">return</span> ComplexAbsDifference(a, b) </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下别名的真实类型是泛型的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliasA = A <span class="comment">// 错误 ❌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliasA = A[<span class="type">int</span>] <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>其中错误的问题是别名不能直接使用泛型类型 <code>cannot use generic type A[T any] without instantiation</code>，它需要泛型实际赋值</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>下面展示一下 go 泛型的基本使用方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>,Age[<span class="type">int</span>](<span class="number">12</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(t T)</span></span> T&#123;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是函数使用泛型的写法，当函数使用泛型的时候，需要在变量前使用中括号标注泛型的具体约束，然后后面才能使用这个泛型类型，使用泛型函数的时候，中括号是可以省略的 <code>Age(12)</code> 系统会自动推算泛型的具体实现。顺便说一下，泛型类型使用 <code>%v</code> 作为占位符，也就是默认的类型，泛型类型无法进行断言。</p>
<p>当然了，我么也可以不用 any，自定义一个约束</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Age[<span class="type">int</span>](<span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> st <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="type">int</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Age</span>[<span class="title">T</span> <span class="title">st</span>]<span class="params">(t T)</span></span> &#123;</span><br><span class="line">	fmt.Println((t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了在函数内的泛型，我们在看一下在方法中如何使用泛型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">new</span>(Age[<span class="type">int</span>]).Post(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dd DD[<span class="type">int</span>]</span><br><span class="line">	dd.TT(<span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Age[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	I T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Age[T])</span></span> Post(t T) &#123;</span><br><span class="line">	fmt.Println(a.I, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DD[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(dd *DD[T])</span></span>TT(t T)&#123;</span><br><span class="line">	fmt.Println(t,<span class="built_in">len</span>(*dd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 age 结构体声明的时候，声明了一个泛型 T，在 struct 体内就可以使用这个 T，方法内部仅可以使用定义在这个结构体对象上的泛型</p>
<p>下面是一个<strong>错误案例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Age[T])</span></span>Post[B any](t T,b B) &#123;</span><br><span class="line">	fmt.Println(a.I, t)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>syntax error: method must have no type parameters</code></p>
<p>接下来我们看一下，如何使用有类型也有方法的泛型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d DDD</span><br><span class="line">	<span class="keyword">var</span> i DDD</span><br><span class="line">	d = <span class="number">1</span></span><br><span class="line">	i = <span class="number">2</span></span><br><span class="line">	io := AbsDifference[DDD](d, i)</span><br><span class="line">	fmt.Println(io)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DDD <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ddd DDD)</span></span> Abs() DDD &#123;</span><br><span class="line">	<span class="keyword">return</span> ddd + ddd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumericAbs[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> |</span><br><span class="line">		~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">		~<span class="type">float32</span> | ~<span class="type">float64</span> |</span><br><span class="line">		~<span class="type">complex64</span> | ~<span class="type">complex128</span></span><br><span class="line">	Abs() T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbsDifference computes the absolute value of the difference of</span></span><br><span class="line"><span class="comment">// a and b, where the absolute value is determined by the Abs method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsDifference</span>[<span class="title">T</span> <span class="title">NumericAbs</span>[<span class="title">T</span>]]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	d := a - b</span><br><span class="line">	<span class="keyword">return</span> d.Abs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>泛型的第一种方法是在编译这个泛型时，使用一个字典，里面包含了这个泛型函数的全部类型信息，然后当运行时，使用函数实例化的时候从这个字典中取出信息进行实例化即可，这种方法会导致执行性能下降，一个实例化类型 <code>int, x=y</code> 可能通过寄存器复制就可以了，但是泛型必须通过内存了 (因为需要字典进行运行时赋值)，不过好处就是不浪费空间</p>
<p>还有一种方法就是把这个泛型的所有类型全部提前生成，这种方法也有一个巨大的缺点就是代码量直线上升，如果是一个包的情况下还能根据具体的函数调用去实现该实现的类型，如果是包输出的的情况下，那么就得不得不生成所有的类型。</p>
<p>所以将两者结合在一起或许是最好的选择。</p>
<p>这种方法是这样的，如果类型的内存分配器&#x2F;垃圾回收器呈现的方式一致的情况下，只给它生成一份代码，然后给它一个字典来区分不同的具体行为，可以最大限度的平衡速度和体积</p>
<h2 id="跟其它语言的泛型进行对比"><a href="#跟其它语言的泛型进行对比" class="headerlink" title="跟其它语言的泛型进行对比"></a>跟其它语言的泛型进行对比</h2><ul>
<li>c 语言：本身不具有泛型，需要程序员去实现一个泛型，实现复杂，但是不增加语言的复杂度 (换言之只增加了程序员的)</li>
<li>c++和 rust：跟 go 基本保持一种方式，就是增加编译器的工作量</li>
<li>Java：将泛型装箱为 object，在装箱和拆箱擦除类型的过程中，程序执行效率会变低</li>
</ul>
<h3 id="为什么-Java-编译器不在编译期就完成泛型的装箱操作呢？"><a href="#为什么-Java-编译器不在编译期就完成泛型的装箱操作呢？" class="headerlink" title="为什么 Java 编译器不在编译期就完成泛型的装箱操作呢？"></a>为什么 Java 编译器不在编译期就完成泛型的装箱操作呢？</h3><p>主要有以下几个原因：</p>
<ol>
<li><p>编译期装箱需要编译器对代码细节有完整信息。但是泛型类型信息可能来自其他模块或第三方库，编译器难以完整获取。</p>
</li>
<li><p>即使编译器可以提前装箱，也需要代码里有大量反射样板代码来还原原始泛型类型，违背泛型设计初衷。</p>
</li>
<li><p>编译期装箱也无法很好处理运行期检查和转换的各种边界情况。</p>
</li>
</ol>
<h2 id="用例子学泛型"><a href="#用例子学泛型" class="headerlink" title="用例子学泛型"></a>用例子学泛型</h2><p>理论学习完了，不使用例子进行复习的话会忘的很快的。跟着我看几个例子吧</p>
<h3 id="函数泛型-map-filter-reduce"><a href="#函数泛型-map-filter-reduce" class="headerlink" title="函数泛型 map-filter-reduce"></a>函数泛型 <code>map-filter-reduce</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	vM := Map[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> i + i</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map的结果是：%v&quot;</span>, vM)</span><br><span class="line">	vF := Filter[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(t <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t &gt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;filter的结果是:%v&quot;</span>, vF)</span><br><span class="line">	vR := Reduce[Value, *Result]([]Value&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;tt&quot;</span>, year: <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;bb&quot;</span>, year: <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;7i&quot;</span>, year: <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;8i&quot;</span>, year: <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;u4i&quot;</span>, year: <span class="number">5</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;uei&quot;</span>, year: <span class="number">6</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;uwi&quot;</span>, year: <span class="number">7</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;uti&quot;</span>, year: <span class="number">8</span>&#125;,</span><br><span class="line">	&#125;, &amp;Result&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(r *Result, v Value)</span></span> *Result &#123;</span><br><span class="line">		r.value = r.value + v.year</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;reduce的结果是：&quot;</span>, vR.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map:类似于洗菜，进去的菜和出来的菜不一样了所以需要两种种类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(arr []T1, f <span class="keyword">func</span>(T1)</span></span> T2) []T2 &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T2, <span class="built_in">len</span>(arr))</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		result[k] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter:类似于摘菜，进去的菜和出来的菜是一种，不过量减少了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(arr []T, f <span class="keyword">func</span>(T)</span></span> <span class="type">bool</span>) []T &#123;</span><br><span class="line">	<span class="keyword">var</span> result []T</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> f(v) &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce:类似于做菜，将菜做成一道料理，所以需要两种类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(arr []T1, zero T2, f <span class="keyword">func</span>(T2, T1)</span></span> T2) T2 &#123;</span><br><span class="line">	result := zero</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		result = f(result, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	year <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map的结果是：[2 4 6 8 10] filter的结果是:[3 4 5] reduce的结果是： 36</code></p>
<h3 id="例子二：方法上的泛型-sets"><a href="#例子二：方法上的泛型-sets" class="headerlink" title="例子二：方法上的泛型 sets"></a>例子二：方法上的泛型 <code>sets</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里 Sets的具体类型和Make的具体类型都是int,所以可以正常赋值</span></span><br><span class="line">	<span class="keyword">var</span> s Sets[<span class="type">int</span>] = Make[<span class="type">int</span>]()</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	s.Add(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(s.Contains(<span class="number">3</span>))</span><br><span class="line">	fmt.Println(s.Len())</span><br><span class="line">	s.Iterate(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	s.Delete(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets 一个key  存储对象</span></span><br><span class="line"><span class="keyword">type</span> Sets[T comparable] <span class="keyword">map</span>[T]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make 实例化一个map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span>[<span class="title">D</span> <span class="title">comparable</span>]<span class="params">()</span></span> Sets[D] &#123;</span><br><span class="line">	<span class="comment">// 泛型就像一个管道一样，只要实例化的时候管子里的东西一致，那么就是一根管子</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>(Sets[D])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向这个sets添加内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Add(t T) &#123;</span><br><span class="line">	s[t] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete ,从这个sets中删除内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Delete(t T) &#123;</span><br><span class="line">	<span class="built_in">delete</span>(s, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Contains 播报t是否属于这个sets</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Contains(t T) <span class="type">bool</span> &#123;</span><br><span class="line">	_, ok := s[t]</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Len sets拥有的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate 迭代器，并且给予每个元素功能</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sets[T])</span></span> Iterate(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> s &#123;</span><br><span class="line">		f(k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map[1:&#123;&#125; 2:&#123;&#125;] false 2 1 2 map[1:&#123;&#125; 2:&#123;&#125;] map[1:&#123;&#125;] </code></p>
<h3 id="例子三：外部定义的约束-实现一个sort接口类型"><a href="#例子三：外部定义的约束-实现一个sort接口类型" class="headerlink" title="例子三：外部定义的约束 实现一个sort接口类型"></a>例子三：外部定义的约束 <code>实现一个sort接口类型</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~ 代表只要底层满足这些类型也可以算满足约束</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> | ~<span class="type">uintptr</span> |</span><br><span class="line">		~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> |</span><br><span class="line">		~<span class="type">float32</span> | ~<span class="type">float64</span> | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> orderedSlice[T Ordered] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s orderedSlice[T])</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedSlice</span>[<span class="title">T</span> <span class="title">Ordered</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	sort.Sort(orderedSlice[T](s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><h3 id="关于泛型中的零值"><a href="#关于泛型中的零值" class="headerlink" title="关于泛型中的零值"></a>关于泛型中的零值</h3><p>在 go 里面对泛型的零值并没有一个所谓的泛型零值可以使用，需要根据不同的实践去实现，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Aget[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	t *T</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据实际判断，如果a的t不等于nil再返回，如果是nil就返回一个T类型的nil（意思就是只声明）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Aget[T])</span></span> Approach() T &#123;</span><br><span class="line">	<span class="keyword">if</span> a.t != <span class="literal">nil</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> *a.t</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> r T</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上目前，还没一个确切的泛型的零值，那么我们要做的只能是按照实际来具体分析，按照提案，以后有可能使用 <code>return ...</code> <code>return _</code> <code>return </code> <code>return nil</code> <code>return T&#123;&#125;</code> 这些都是可能的结果，我个人比较喜欢 <code>return T&#123;&#125;</code> 来表示泛型的零值，拭目以待吧。</p>
<h3 id="无法识别使用了底层数据的其它类型"><a href="#无法识别使用了底层数据的其它类型" class="headerlink" title="无法识别使用了底层数据的其它类型"></a>无法识别使用了底层数据的其它类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewtonSqrt</span>[<span class="title">T</span> <span class="title">Float</span>]<span class="params">(v T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">var</span> iterations <span class="type">int</span></span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">interface</span>&#123;&#125;)(v).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">float32</span>:</span><br><span class="line">		iterations = <span class="number">4</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">		iterations = <span class="number">5</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T&quot;</span>, v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Code omitted.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> G = NewtonSqrt(MyFloat(<span class="number">64</span>))</span><br></pre></td></tr></table></figure>
<p>这里约束 Float 拥有的约束类型是 <code>~float32</code> 和 <code>float64</code> 当在 switch 中定义了 float32 和 flaot64 时，无法识别下面的新类型 MyFloat 即使它的底层时 float32，go 的提议是以后在 switch 中使用 <code>case ~float32:</code> 来解决这个问题，目前尚未解决这个问题</p>
<h3 id="即便约束一致，类型也是不同的"><a href="#即便约束一致，类型也是不同的" class="headerlink" title="即便约束一致，类型也是不同的"></a>即便约束一致，类型也是不同的</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(dst []T1, src []T2)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> src &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="built_in">len</span>(dst) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		dst[i] = T1(x) <span class="comment">// x 是 T2类型 不能直接转化为 T1类型</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>T1，和 T2 虽然都是 any 的约束，但是啊，它不是一个类型啊！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy[<span class="type">int</span>,<span class="type">string</span>]() <span class="comment">// 这种情况下，你能说可以直接转化吗？？？</span></span><br></pre></td></tr></table></figure>
<p>这种代码可以更改一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst[i]= (<span class="keyword">interface</span>&#123;&#125;)(x).(T1)</span><br></pre></td></tr></table></figure>
<p>确认是一种类型以后才能转化</p>
<!--
 * @Author: shgopher shgopher@gmail.com
 * @Date: 2022-11-17 20:40:42
 * @LastEditors: shgopher shgopher@gmail.com
 * @LastEditTime: 2023-11-29 11:49:04
 * @FilePath: /GOFamily/工程/错误处理/README.md
 * @Description: 
 * 
 * Copyright (c) 2023 by shgopher, All Rights Reserved. 
-->
<h1 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h1><h2 id="错误处理的基本认识"><a href="#错误处理的基本认识" class="headerlink" title="错误处理的基本认识"></a>错误处理的基本认识</h2><p>在 go 语言中，没有传统编程语言的 <code>try - catch</code> 操作，go 语言中一切错误都需要显式处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := readFile(<span class="string">&quot;./x&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，我们规定函数返回的最后一个数据是错误接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">(v <span class="type">int</span>)</span></span>(<span class="type">int</span>, <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>, fmt.Errorf(<span class="string">&quot;错误x&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接返回一个 err 是一种简单的做法，如果错误比较初级也可以这么做，但是如果想要带有更精确的提示信息，可以在返回的时候 wrap 一层信息：</p>
<p>就以上文的读取数据为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := readFile(<span class="string">&quot;./&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;在读取数据的时候发生了错误，错误信息是：%w&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wrap 一层信息，对于错误的定位更加高效</p>
<h2 id="Error-的本质是什么？"><a href="#Error-的本质是什么？" class="headerlink" title="Error 的本质是什么？"></a>Error 的本质是什么？</h2><p>错误处理的核心就是下面这一个 error 的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span>&#123;</span><br><span class="line">	Error()<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以只要我们的自建类型实现了这个接口，就可以使用很多的错误处理的方法。</p>
<h3 id="自定义-error"><a href="#自定义-error" class="headerlink" title="自定义 error"></a>自定义 error</h3><p>我们使用 errors.New() 的时候其实就是返回了一个 go 自建的，叫做 errorString 的实现了 error 接口的结构体。<br>这就是自建 error 的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := errors.New(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="built_in">println</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (0x47fd48,0xc00003e730)</span></span><br></pre></td></tr></table></figure>
<p>为了防止在比较错误的时候发生错误一致的情况，所以自建 error，返回的实际上是一个指针。</p>
<blockquote>
<p>下文会提用什么方法进行比较 err，实际上就是 “两个接口类型是否相等 — 类型一致，值一致”，如果返回的值是指针，那么值肯定就不可能一样了。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 源代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;s&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用 fmt.Errorf() 的时候，其实也是使用的上述方法。</p>
<p>不过，如果我们使用了占位符 <code>%w</code> 时，将不会使用上述方法，而是使用了 wrapError：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="type">string</span></span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *wrapError)</span></span> Error()<span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *wrapError)</span></span> Unwrap() <span class="type">error</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式主要是为了错误链，那就让我们看一下如何使用错误链的相关操作。</p>
<h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is()"></a>errors.Is()</h3><p>上文我们说到，错误可以使用 wrap 的方式进行封装，那么如果我们想判断封装的这么多层的错误中，有没有哪一层错误等于我们要的值，可以使用这个函数进行判断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := errors.New(<span class="string">&quot;err is now&quot;</span>)</span><br><span class="line">	err1 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err)</span><br><span class="line">	err2 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err1)</span><br><span class="line">	<span class="keyword">if</span> errors.Is(err2,err) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;是一个错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As()"></a>errors.As()</h3><p>这个方法跟上文的 Is() 类似，只不过它判断的是类型是否一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errS <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *errS)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := &amp;errS&#123;<span class="string">&quot;typical error&quot;</span>&#125;</span><br><span class="line">err1 := fmt.Errorf(<span class="string">&quot;wrap err: %w&quot;</span>, err)</span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;wrap err1: %w&quot;</span>, err1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e *errS</span><br><span class="line"><span class="comment">// 这里的 target 必须使用指针</span></span><br><span class="line"><span class="keyword">if</span> !errors.As(err2, &amp;e) &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;TypicalErr is not on the chain of err2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;TypicalErr is on the chain of err2&quot;</span>)</span><br><span class="line">	<span class="built_in">println</span>(err == e)</span><br></pre></td></tr></table></figure>
<h3 id="errors-Join"><a href="#errors-Join" class="headerlink" title="errors.Join()"></a>errors.Join()</h3><p>这个方法是将几个错误结合在一起的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err1 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err)</span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;err1:%w&quot;</span>,err1)</span><br><span class="line">err := errors.Join(err1,err2)</span><br></pre></td></tr></table></figure>
<h2 id="当错误处理遇到了-defer"><a href="#当错误处理遇到了-defer" class="headerlink" title="当错误处理遇到了 defer"></a>当错误处理遇到了 defer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> xx &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> ,err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段伪代码的意思是说，当有条件之后，返回一个错误，但是 defer 的内容发生在这个 err 被固定之后，所以 defer 中如果再有错误将不会被处理。</p>
<p>那么我们该怎么更改呢？</p>
<p>我想你一定想到了前文我们说过，使用带有变量的返回值是可以将 defer 的值进行返回的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> ( i <span class="type">int</span>, e <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> xx &#123;</span><br><span class="line">			e = xx</span><br><span class="line">			i = xx</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这种写法，defer 中如果发生了错误就会覆盖掉了程序执行中的 err，所以这种方法也是不行的，即使它能照顾到了 defer 中的错误处理。</p>
<p>我们可以将错误处理都放在 defer 中处理就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> ( i <span class="type">int</span>, e <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> xx &#123;</span><br><span class="line">		i = xx</span><br><span class="line">		e = xx</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		e1 := f.<span class="built_in">close</span>()</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>  e1 != <span class="literal">nil</span> &#123;</span><br><span class="line">					log(e1) </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> </span><br><span class="line">		&#125;</span><br><span class="line">		err = e1</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，两种错误都能处理到了</p>
<h2 id="错误处理实战的五种方式"><a href="#错误处理实战的五种方式" class="headerlink" title="错误处理实战的五种方式"></a>错误处理实战的五种方式</h2><h3 id="经典的错误处理方式"><a href="#经典的错误处理方式" class="headerlink" title="经典的错误处理方式"></a>经典的错误处理方式</h3><p>每一个步骤分别直接处理错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> age <span class="keyword">interface</span>&#123;</span><br><span class="line">	getAge()<span class="type">error</span></span><br><span class="line">	putAge()<span class="type">error</span></span><br><span class="line">	allAge()<span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">D</span><span class="params">(ag age)</span></span><span class="type">error</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> err != ag.getAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != ag.putAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != ag.allAge();err != <span class="literal">nil</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屏蔽过程中的错误处理"><a href="#屏蔽过程中的错误处理" class="headerlink" title="屏蔽过程中的错误处理"></a>屏蔽过程中的错误处理</h3><p>将错误放置在对象的内部进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileCopier <span class="keyword">struct</span>&#123;</span><br><span class="line">	w *os.File</span><br><span class="line">	r *os.File</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FileCopier)</span></span>open(path <span class="type">string</span>)( *os.File,<span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, f.err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		f.err = err</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(f *FileCopier)</span></span>OpenSrc(path <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	f.r,f.err = os.Open(path)</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(f *FileCopier)</span></span> CopyFile(src, dst <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> f.r != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.r.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> f.w!= <span class="literal">nil</span> &#123;</span><br><span class="line">			f.w.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> f.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> f.w != <span class="literal">nil</span> &#123;</span><br><span class="line">				os.Remove(dst)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	f.opensrc(src)</span><br><span class="line">	f.createDst(dst)</span><br><span class="line">	<span class="keyword">return</span> f.err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码并不是特别完整，但是从中我们还是可以理解这种将错误放在对象中的写法的技巧。</p>
<p>首先，错误直接放置在对象自身，在方法中首先去调用这个字段来看是否拥有错误，如果有，直接退出即可</p>
<p>如果没有错误继续往下走，如果本次方法发生错误就继续将这个错误赋值给这个字段，</p>
<p>当最后处理的方法时，这里也就是 copyfile 方法，我们在 defer 中要对于各个子方法进行判断，到底是哪个方法有错误，然后逐一进行判定。相当于处理错误的逻辑集中放置到了最后一个函数进行执行了。</p>
<p>也就是说，将错误放置在对象本身的时候，通常应该为顺序调用的方法，一旦前者出现错误，后者即可退出</p>
<p>如果不是顺序的执行过程，那么有些的错误就可能被湮没，导致错误无法被感知。</p>
<h3 id="分层架构中的错误处理方法"><a href="#分层架构中的错误处理方法" class="headerlink" title="分层架构中的错误处理方法"></a>分层架构中的错误处理方法</h3><p>常见的分层架构</p>
<ul>
<li>controller 控制层</li>
<li>service 服务层</li>
<li>dao 数据访问层</li>
</ul>
<p>dao 层生产错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service 追加错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err := a.Dao.getName()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;getname err: %w&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller 打印错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">	log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pkg-errors"><a href="#pkg-errors" class="headerlink" title="pkg&#x2F;errors"></a>pkg&#x2F;errors</h3><p>如果感觉标准库提供的错误处理不够丰富，也可以使用 github.com&#x2F;pkg&#x2F;errors 来处理错误</p>
<p>此包常用的方法有</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成新的错误，同样会附加堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span><span class="type">error</span></span><br><span class="line"><span class="comment">// 只附加新的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err <span class="type">error</span>,message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"><span class="comment">// 只附加堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span><span class="type">error</span></span><br><span class="line"><span class="comment">// 附加信息 + 堆栈信息(就是一大堆的各种文件的堆栈调用过程的详细信息)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrapf</span><span class="params">(err <span class="type">error</span>,format <span class="type">string</span>,args...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"><span class="comment">// 获取最根本的错误（错误链的最底层）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := age()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// %+v 是 pkg/errors 包提供的格式化输出格式，输出错误堆栈</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%+v&quot;</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用这个 pkg&#x2F;errors 包的时候要注意一件事，因为 wrap 可以包装堆栈向上输出，如果你调用的第三方库使用了 wrap，你再次使用 wrap，那么就会出现两堆相同的堆栈信息，这造成了极大的冗余。</p>
<p>所以，</p>
<ul>
<li>在提供多人使用的三方库的时候不要使用 wrap，只有逻辑代码的时候使用 wrap 的功能</li>
<li>遇到一个错误不打算处理，那么要带上足够多的信息再向上抛出</li>
<li>一旦错误处理完成之后就没有错误了，不再需要把错误继续网上抛，返回 nil 即可</li>
</ul>
<p>所以我们使用 pkg&#x2F;errors 包将上面的分层写法做一个更完善的改进：</p>
<p>dao 层生产错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span><span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 返回此处的错误堆栈</span></span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;error:&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>service 追加错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err := a.getName()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 不返回堆栈了，仅仅添加错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err,<span class="string">&quot;getName error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller 打印错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 添加日志</span></span><br><span class="line">	log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="errgroup-的使用技巧"><a href="#errgroup-的使用技巧" class="headerlink" title="errgroup 的使用技巧"></a>errgroup 的使用技巧</h3><p>errgroup 的使用方法是 golang.org&#x2F;x&#x2F;sync&#x2F;errgroup</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g, ctx := errgroup.WithContext(context.Background())</span><br><span class="line">	<span class="comment">// 启动一个 goroutine去处理错误</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error1&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error2&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 类似 waitgroup 的 wait 方法</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理相关技巧"><a href="#错误处理相关技巧" class="headerlink" title="错误处理相关技巧"></a>错误处理相关技巧</h2><p>这里会介绍在实战过程中用到的诸多技巧</p>
<h3 id="使用-errors-New-时要写清楚包名"><a href="#使用-errors-New-时要写清楚包名" class="headerlink" title="使用 errors.New() 时要写清楚包名"></a>使用 errors.New() 时要写清楚包名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> age</span><br><span class="line"></span><br><span class="line">ErrMyAge := errors.New(<span class="string">&quot;age: ErrMyAge is error&quot;</span>)</span><br><span class="line">ErrMyAddress := errors.New(<span class="string">&quot;age: ErrMyAddress is error&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用-error-处理一般错误，使用-panic-处理严重错误-异常"><a href="#使用-error-处理一般错误，使用-panic-处理严重错误-异常" class="headerlink" title="使用 error 处理一般错误，使用 panic 处理严重错误 (异常)"></a>使用 error 处理一般错误，使用 panic 处理严重错误 (异常)</h3><p>使用这种模型就避免了类似 Java 那种所有错误都一样的行为，Java 的使用 try-catch 的方式导致任何错误都是一个方式去处理，非常有可能让程序员忽略错误的处理</p>
<p>然而 go 不同，<strong>错误</strong>使用 error，<strong>异常</strong>使用 panic 的方式去处理。</p>
<ul>
<li>错误：error</li>
<li>异常：panic</li>
</ul>
<p>假设我们在代码中使用了 panic，通常来说，为了代码的健壮性还是会使用 defer 函数去运行一个 recover() 的，程序的存活比啥都重要。</p>
<h3 id="基础库，应该避免使用-error-types"><a href="#基础库，应该避免使用-error-types" class="headerlink" title="基础库，应该避免使用 error types"></a>基础库，应该避免使用 error types</h3><p>因为这种写法容易造成代码的耦合，尤其是在我们写的基础库中，非常容易造成改动代码来引入的不健壮性。</p>
<p>使用自定义的 error type</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了额外增加更多的错误信息，字段需大写</span></span><br><span class="line"><span class="keyword">type</span> ErrMyAge <span class="keyword">struct</span> &#123;</span><br><span class="line">	EV <span class="type">string</span></span><br><span class="line">	MErr <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ErrMyAge)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;age: %s&quot;</span>, e.EV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := &amp;ErrMyAge&#123;<span class="string">&quot;err age is hi&quot;</span>&#125;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 errors.New() 哨兵错误模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我方代码</span></span><br><span class="line">ErrAge := errors.New(<span class="string">&quot;age: ErrAge is error&quot;</span>)</span><br><span class="line">ErrAddress := errors.New(<span class="string">&quot;age: ErrAddress is error&quot;</span>)</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;github.com/shgopher/age&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 带来了耦合</span></span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, age.ErrAge)&#123;</span><br><span class="line">		<span class="comment">// 处理</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上他们都是 error types，只不过前者比后者增加了很多额外的信息，但是相同点是，他们都造成了耦合</p>
<p>如果别人使用了这个基础库，那么势必这些错误就会跟使用者的代码耦合，我们改动了代码，第三方的代码就会因此受到影响。</p>
<p>因此，在对外暴露的基础包中，我们应尽量减少定义哨兵错误 (上述定义方法被称之为哨兵模式的错误)</p>
<p>上述提供的哨兵模式是透明的错误导出机制，所以容易造成耦合</p>
<p>我们可以提供不透明的机制，不导出透明的错误类型，仅仅让用户判断是否等于 nil，就可以防止耦合的存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">&quot;github.com/shgopher/age&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err:= age.Bar(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是大多数程序应该提供的模式，不对外暴露，避免了耦合</p>
<p>那么这种方法的缺陷也很明显了，就是无法获取更多的错误信息，理论上来说，我们也没必要获取那么多错误信息，但是如果真的要获取错误信息了，该如何去做呢？</p>
<p>我们可以向外暴露一些动作，只暴露行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mage <span class="keyword">interface</span> &#123;</span><br><span class="line">	age() <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个对外暴露的函数可以对外输出行为</span></span><br><span class="line"><span class="comment">// 并且还不用暴露出具体的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsMage</span><span class="params">(err <span class="type">error</span>)</span></span><span class="type">bool</span> &#123;</span><br><span class="line">	 a, ok := err.(mage)</span><br><span class="line">	 <span class="keyword">return</span> ok &amp;&amp; a.age()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化不必要的代码让程序变得更简洁"><a href="#优化不必要的代码让程序变得更简洁" class="headerlink" title="优化不必要的代码让程序变得更简洁"></a>优化不必要的代码让程序变得更简洁</h3><p>方法一将大函数变小函数，通过封装函数的方法从视觉上降低 if err 的影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造之前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(src ,dst <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r,err := os.Open(src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> w,err := os.Create(dst); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.Cloase()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _,err := io.Copy(w,r); err!= <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面两个操作封装成一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenD</span><span class="params">(src dst <span class="type">string</span>)</span></span> (*os.File,*os.File,<span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> r ,w *os.File </span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> r,err = os.Open(src); err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> w,err = os.Create(dst); err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		r.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r,w,err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数就只有一个 if err 了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(src,dst <span class="type">string</span>)</span></span><span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">var</span> r, w *os.File</span><br><span class="line">	<span class="keyword">if</span> r,w,err = OpenD(src,dst); err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		r.Close()</span><br><span class="line">		w.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> _,err = io.Copy(w,r); err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二将代码中不必要的成分删除，来保证代码的简洁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthticateRequest</span><span class="params">(r *Request)</span></span><span class="type">error</span>&#123;</span><br><span class="line">	err := authticate(r.User)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上 authticate 只返回一个 error 类型的接口，根本不需要判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthticateRequest</span><span class="params">(r *Request)</span></span><span class="type">error</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> authticate(r.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三使用更加合适的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要逐行去读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Countlines</span><span class="params">(r io.Reader)</span></span>(<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">		br = bufio.NewReader(r)</span><br><span class="line">		line <span class="type">int</span></span><br><span class="line">		err <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_,err = br.readline(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		line ++ </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>,err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> lines,<span class="literal">nil</span></span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码看起来也是很合理的样子，也很简洁，但是，我们其实用的函数不是特别的合适</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实这里使用 scan 更加合适，代码量更加精简，并且结构异常舒服</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Countlines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>,<span class="type">error</span>)&#123;	</span><br><span class="line">	sc := bufio.NewScanner(r)</span><br><span class="line">	lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误应该只处理一次"><a href="#错误应该只处理一次" class="headerlink" title="错误应该只处理一次"></a>错误应该只处理一次</h3><p>我们有日志系统，有些时候我们发现一个错误，然后打了一个日志，然后又把错误给 return 了，实际上这与 go 语言哲学中说的错误只处理一次相违背</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span>&#123;</span><br><span class="line">	 _, err := os.Open(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span>  err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Prinln(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span><span class="type">error</span>&#123;</span><br><span class="line">	 _, err := os.Open(<span class="string">&quot;./a&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span>  err!= <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err,<span class="string">&quot;open error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的处理方法是错误只处理一次，那么在什么时候处理呢？</p>
<p>上文提到了多层的架构设计，我们在底层 (带有堆栈的错误向上抛出) 和中层 (仅仅附加信息再次向上抛出) 仅仅是向上抛出，并不需要将错误记录在日志中，在应用层才需要去使用日志记录错误，日志记录完错误以后，也不需要再向上抛出错误了 (最顶端了) 完全满足 “只处理一次错误” 的要求。</p>
<h2 id="业务-code-码的设置"><a href="#业务-code-码的设置" class="headerlink" title="业务 code 码的设置"></a>业务 code 码的设置</h2><p>常见的 http 错误码数量较少，比如常见的只有例如 404 301 302 200 503 等，绝对数量还是较少，无法去表达业务上的错误，因此我们需要设置一套能表达具体生产业务的 code 码。</p>
<p>为了保证服务端的安全，我们设置的 code 码应该设置两套数据，一套显示给客户端，一套自用，以此来保证服务端的绝对安全。</p>
<p>有三种设计业务 code 码的方式：</p>
<h3 id="一律返回-http-status-200，具体-code-码单独设置"><a href="#一律返回-http-status-200，具体-code-码单独设置" class="headerlink" title="一律返回 http status 200，具体 code 码单独设置"></a>一律返回 http status 200，具体 code 码单独设置</h3><p>例如</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Syntax error \&quot;Field picture specified more than once. This is only possible before version 2.1\&quot; at character 23: id,name,picture,picture&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OAuthException&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">2500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fbtrace_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>http status code 通通 200</li>
<li>code 2500，才是真实的面向客户端的 code 码</li>
</ul>
<p>使用这种方法的一大缺陷就是必须解析 body 内容才能发现具体的错误业务码，很多场景我们仅仅需要知道返回的是成功或者错误，并不需要知晓具体的业务码，这是这种方式的一大弊端。</p>
<h3 id="使用合适的-http-status-code-简单的信息以及业务错误代码"><a href="#使用合适的-http-status-code-简单的信息以及业务错误代码" class="headerlink" title="使用合适的 http status code + 简单的信息以及业务错误代码"></a>使用合适的 http status code + 简单的信息以及业务错误代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">x-connection-hash: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">set-cookie: guest_id=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">Date: Thu, 01 Jun 2017 03:04:23 GMT</span><br><span class="line">Content-Length: 62</span><br><span class="line">x-response-time: 5</span><br><span class="line">strict-transport-security: max-age=631138519</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Server: tsa_b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里：仅仅返回简单的错误信息</span></span><br><span class="line">&#123;<span class="string">&quot;errors&quot;</span>:[&#123;<span class="string">&quot;code&quot;</span>:215,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Bad Authentication data.&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案也是大多数公司采纳的方案，使用具体的 http status code 可以知晓大概的业务类型，是错误还是正常运行，然后使用简单的错误信息和业务错误代码去定位具体的错误</p>
<p>如果业务不是特别复杂，使用这种方式即可</p>
<h3 id="使用合适的-http-status-code-非常详细的业务错误代码以及信息"><a href="#使用合适的-http-status-code-非常详细的业务错误代码以及信息" class="headerlink" title="使用合适的 http status code + 非常详细的业务错误代码以及信息"></a>使用合适的 http status code + 非常详细的业务错误代码以及信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400</span><br><span class="line">Date: Thu, 01 Jun 2017 03:40:55 GMT</span><br><span class="line">Content-Length: 276</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Server: Microsoft-IIS/10.0</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;SearchResponse&quot;</span>:&#123;<span class="string">&quot;Version&quot;</span>:<span class="string">&quot;2.2&quot;</span>,<span class="string">&quot;Query&quot;</span>:&#123;<span class="string">&quot;SearchTerms&quot;</span>:<span class="string">&quot;api error codes&quot;</span>&#125;,<span class="string">&quot;Errors&quot;</span>:[&#123;<span class="string">&quot;Code&quot;</span>:1001,<span class="string">&quot;Message&quot;</span>:<span class="string">&quot;Required parameter is missing.&quot;</span>,<span class="string">&quot;Parameter&quot;</span>:<span class="string">&quot;SearchRequest.AppId&quot;</span>,<span class="string">&quot;HelpUrl&quot;</span>:<span class="string">&quot;http\u003a\u002f\u002fmsdn.microsoft.com\u002fen-us\u002flibrary\u002fdd251042.aspx&quot;</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>当业务逻辑稍微复杂一些，并且需要极其精准和快速的定位错误时，就需要在返回的 body 中去设置非常详细的错误信息</p>
<p><strong>综上所述：</strong></p>
<ul>
<li>使用正确的 http status code 让业务的第一步变得更加直观</li>
<li>区别于 http status code，具体业务的 code 码会更加丰富</li>
<li>返回尽可能详细的错误，有助于复杂逻辑的快速错误定位</li>
<li>直接返回给客户的错误代码不应该包括敏感信息，敏感信息的 code 码仅供内部使用</li>
<li>错误信息要求规范，简洁以及有用</li>
</ul>
<h3 id="业务-code-码的具体设计"><a href="#业务-code-码的具体设计" class="headerlink" title="业务 code 码的具体设计"></a>业务 code 码的具体设计</h3><p>引入业务 code 码的核心原因就是 http status code 太少，以及他们并不能跟具体业务挂钩。</p>
<p>当我们设置好良好又详细的 code 码时，我们就可以快速定位业务代码，以及可以快速知晓发生错误的等级模块，具体信息等</p>
<p>下面给出具体的设计思路：<strong>纯数字表达，不同的数字段表达不同的模块不同的业务</strong></p>
<p>例如 100101</p>
<ul>
<li>10：表示某个服务</li>
<li>01：表示某个服务下的模块</li>
<li>01：模块下的错误码</li>
</ul>
<p>10 服务 01 模块 01 错误，— 服务 10 数据库模块未找到记录错误</p>
<p>一共最多有 100 个服务，每个服务最多有 100 个模块，每个模块最多有 100 个错误，如果某些模块 100 个都不够用，那怎么这个模块有必要去拆分一下了。</p>
<h3 id="如何设置-http-status-code"><a href="#如何设置-http-status-code" class="headerlink" title="如何设置 http status code"></a>如何设置 http status code</h3><ul>
<li><code>1xx</code>：请求已接收，继续处理</li>
<li><code>2xx</code>：成功处理了请求</li>
<li><code>3xx</code>：请求被重定向</li>
<li><code>4xx</code>：请求错误</li>
<li><code>5xx</code>：服务器错误</li>
</ul>
<p>由于 http status code 相对数量也不算太少，如果每一个都利用上，难免会增加复杂度，建议仅使用基本的几个即可</p>
<ul>
<li>200 - 表示请求成功执行。</li>
<li>400 - 表示客户端出问题。</li>
<li>500 - 表示服务端出问题。</li>
</ul>
<p>如果上述的感觉太少，再增加下面几个也可以</p>
<ul>
<li>401 - 表示认证失败。</li>
<li>403 - 表示授权失败。</li>
<li>404 - 表示资源找不到，这里的资源可以是 URL 或者 RESTful 资源。</li>
</ul>
<p>将 http status code 控制在<strong>个位数</strong>，有利于后端的逻辑代码简洁性，比如 301 302 确实是代表不同的含义，<strong>前端或许可以设置丰富的 http status code，因为浏览器会进行相关的具体操作，但是后端返回给前端的 http status code 并没有任何的操作，使用过多只会增加复杂度。</strong></p>
<h2 id="设计一个生产级的错误包"><a href="#设计一个生产级的错误包" class="headerlink" title="设计一个生产级的错误包"></a>设计一个生产级的错误包</h2><h3 id="生产级的错误包需要的功能"><a href="#生产级的错误包需要的功能" class="headerlink" title="生产级的错误包需要的功能"></a>生产级的错误包需要的功能</h3><ol>
<li>支持错误堆栈</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">07</span>/<span class="number">02</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">03</span> call <span class="function"><span class="keyword">func</span> <span class="title">got</span> <span class="title">failed</span>: <span class="title">func</span> <span class="title">called</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">main.funcB /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">27</span></span><br><span class="line">main.funcA /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">19</span></span><br><span class="line">main.main /home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/errors/good.<span class="keyword">go</span>:<span class="number">10</span></span><br><span class="line">runtime.main /home/colin/<span class="keyword">go</span>/go1<span class="number">.16</span><span class="number">.2</span>/src/runtime/proc.<span class="keyword">go</span>:<span class="number">225</span>runtime.goexit /home/colin/<span class="keyword">go</span>/go1<span class="number">.16</span><span class="number">.2</span>/src/runtime/asm_amd64.s:<span class="number">1371</span></span><br><span class="line">exit status <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>拥有错误的堆栈，我们才能定位错误的根源。</p>
<ol start="2">
<li><p>支持打印不同的格式比如 %s %w %d</p>
</li>
<li><p>支持 Wrap() Unwrap() 的功能，就是错误的嵌套和反嵌套</p>
</li>
<li><p>错误包要支持 Is() 和 As() 方法，这主要是因为有错误的嵌套，所以无法再使用接口相比较的方式进行判断接口类型是否相等 (类型相同，值相同)</p>
</li>
<li><p>要支持格式化和非格式化的创建方式</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">errors.New(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">fmt.Errorf(<span class="string">&quot;%w&quot;</span>,err)</span><br></pre></td></tr></table></figure>

<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>从 github.com&#x2F;pkg&#x2F;errors 包中改造即可。</p>
<p>增加以下字段的结构体就可以满足上面的需求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> withCode <span class="keyword">struct</span> &#123;</span><br><span class="line">	err   <span class="type">error</span></span><br><span class="line">	code  <span class="type">int</span></span><br><span class="line">	cause <span class="type">error</span></span><br><span class="line">	*stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="issues-1"><a href="#issues-1" class="headerlink" title="issues"></a>issues</h2><p><code>问题一：</code> <strong>请说出下列代码的执行输出</strong>*</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;hi1&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;oops&quot;</span>)</span><br><span class="line">	<span class="comment">// 这里的defer将不会进栈，所以也就不会执行了。</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;hi2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答案是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hi1</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">oops</span><br><span class="line"><span class="built_in">panic</span>: oops</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/tmp/sandbox1932632082/prog.<span class="keyword">go</span>:<span class="number">18</span> +<span class="number">0xa7</span></span><br><span class="line"></span><br><span class="line">Program exited.</span><br></pre></td></tr></table></figure>
<p>解释：Panic，意味着恐慌，意思等于 return，所以 panic 下面的数据是无法执行的，defer 不同，他们是顺序的将这些 defer 函数装入函数内置的 defer 栈的，所以在 return 之后，defer 栈会执行，所以这里的 defer 1 2 3 可以执行，Panic 前面的 hi1 可以执行，但是 Panic 之后，相当于 return 后面的 hi2 就无法执行了。</p>
<p><code>问题二：</code> <strong>看一段代码，分析答案</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;starting f&quot;</span>)</span><br><span class="line">	g(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;behind  g&quot;</span>) <span class="comment">//会终止执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i) <span class="comment">//终止执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">starting f</span><br><span class="line">panicking</span><br><span class="line"><span class="title class_">Defer</span> <span class="keyword">in</span> g <span class="number">2</span></span><br><span class="line">recoverd <span class="keyword">in</span> f</span><br></pre></td></tr></table></figure>

<p>解释一下，首先执行的是 f 函数的代码，然后开始执行 g，在 g 中遇到了 Panic，所以 panic 后面的 parinting in g 就无法执行了，所以执行了 defer in g<br>这个时候 f 中的 g(2) 后面的数据也无法执行了，因为整个 f 也陷入了恐慌，所以它只能 return 进入 defer 了，defer 中刚好有 recover，所以执行了 recover 信息后，就退出了函数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">feynman</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/">http://example.com/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Feynman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><a class="post-meta__tags" href="/tags/%E5%8A%A0%E5%BC%BA/">加强</a></div><div class="post-share"><div class="social-share" data-image="/./img/aiguo.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/" title="焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链"><img class="cover" src="/./img/aiguo.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链</div></div><div class="info-2"><div class="info-item-1">从流程与设备、产品与副产品两个个方面进行介绍</div></div></div></a><a class="pagination-related" href="/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/" title="评论专区"><img class="cover" src="/./img/aiguo.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">评论专区</div></div><div class="info-2"><div class="info-item-1">赛博树洞欢迎来到本博客最欢乐的角落！无论你是技术大佬还是摆烂选手，都可以在这里畅所欲言，评论区等你开大！你的每一句评论，都是我继续摸鱼的动力！ 今日节目单：评论 roll 鼠标垫！  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E5%A4%A9/" title="go语言学习第七天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-09</div><div class="info-item-2">go语言学习第七天</div></div><div class="info-2"><div class="info-item-1">1.发现结构体对方法的调用都是用地址，而有了接口之后是直接用变量？1234567891011121314151617181920212223//结构体对方法的调用type DivideError struct &#123;        Dividend int        Divisor  int&#125;func (e *DivideError) Error() string &#123;        return fmt.Sprintf(&quot;cannot divide %d by %d&quot;, e.Dividend, e.Divisor)&#125;//接口对方法的调用type Shape interface &#123;        Area() float64        Perimeter() float64&#125;type Circle struct &#123;        Radius float64&#125;func (c Circle) Area() float64 &#123;        return math.Pi *...</div></div></div></a><a class="pagination-related" href="/2025/09/03/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9/" title="go语言学习第二天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-03</div><div class="info-item-2">go语言学习第二天</div></div><div class="info-2"><div class="info-item-1">Go语言学习笔记标识符命名规则 当标识符（包括常量、变量、类型、函数名、结构字段等）以大写字母开头时，如 Group1，该标识符可以被外部包的代码访问（需先导入该包），称为“导出”（类似于面向对象语言中的 public）。 如果标识符以小写字母开头，则对包外不可见，但在包内部可见并可用（类似于面向对象语言中的 protected）。  常用指令 运行 Go 文件：go run hello.go 编译 Go 文件（生成可执行文件）：go build hello.go  注意事项 &#123; 不能单独放在一行。 文件名与包名没有直接关系，不要求一致。 同一文件夹下的所有文件只能有一个包名。  </div></div></div></a><a class="pagination-related" href="/2025/09/06/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E5%A4%A9/" title="go语言学习第五天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-06</div><div class="info-item-2">go语言学习第五天</div></div><div class="info-2"><div class="info-item-1">回顾学了array、slice（其实就是一个容量可变的array）、structure、range遍历各个数组和集合的用法、指针。 1.Go切片默认容量扩展机制在 Go 语言中，切片的容量扩展并不是简单的按需分配，而是结合了容量翻倍策略和内存分配器的大小等级取整机制。这样设计的目的是提升分配效率、减少内存碎片，并优化整体性能。  Go 的运行时内存分配器会根据预定义的大小等级分配内存块，而不是每次都精确分配所需字节。 当切片容量不足时，append 操作会触发扩容，通常采用容量翻倍策略，但最终容量会向上取整到最近的大小等级。 例如，追加元素后所需容量为 5，但实际分配的容量为 6，因为 6 个 int 能刚好匹配 48 字节的分配等级。  这种机制虽然可能导致单次分配时多分配一些内存，但能显著提升切片 append 操作的平均性能，减少频繁分配带来的性能损耗。当然，容量也可以自定义！！ 操作过程举例12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;func ...</div></div></div></a><a class="pagination-related" href="/2025/09/04/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9/" title="go语言学习第三天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-04</div><div class="info-item-2">go语言学习第三天</div></div><div class="info-2"><div class="info-item-1">变量作用域 局部变量：在函数体内声明的变量称为局部变量，其作用域仅限于函数体内部。函数的参数和返回值变量也属于局部变量。 全局变量：在函数体外声明的变量称为全局变量，全局变量可以在整个包内，甚至被导出后在外部包中使用。 使用指针变量与不使用的区别：指针变量*（地址）的值会跟随变量的变化而变化，对比：  123456789101112131415func main()&#123;    var a int = 4    var ptr int    ptr = a     fmt.Println(ptr)//4    a = 15    fmt.Println(ptr)//4        var b int = 5     var ptr1 *int    ptr1 = &amp;b     fmt.Println(*ptr1)//5    b=15     fmt.Println(*ptr1)//15 *ptr1的值跟随b的变化而变化&#125;  备注：  局部变量的生命周期仅在函数调用期间，函数调用结束后局部变量会被销毁。 Go 语言中，全局变量与局部变量可以同名，但在函数...</div></div></div></a><a class="pagination-related" href="/2025/09/10/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E5%A4%A9/" title="go语言学习第八天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-10</div><div class="info-item-2">go语言学习第八天</div></div><div class="info-2"><div class="info-item-1">1.Go文件处理 os：核心库，提供底层文件操作（创建、读写、删除等），大多数场景优先使用。 io：提供通用接口（如 Reader&#x2F;Writer），可与文件、网络等数据源交互。 bufio：通过缓冲优化性能，减少 I&#x2F;O 操作次数，适合频繁读写场景。 ioutil：已弃用，Go 1.16 后相关功能已迁移到 os 和 io 包。 path&#x2F;filepath：处理路径，跨平台兼容 Windows&#x2F;Unix 路径分隔符差异。   文件在创建、读取并赋值后要及时关闭，以免资源占用。  2.Go正则表达式使用注意事项常用正则表达式语法表   语法 说明    . 匹配任意单个字符（除了换行符）   * 匹配前面的字符 0 次或多次   + 匹配前面的字符 1 次或多次   ? 匹配前面的字符 0 次或 1 次   \d 匹配数字字符（等价于 [0-9]）   \w 匹配字母、数字或下划线（等价于 [a-zA-Z0-9_]）   \s 匹配空白字符（包括空格、制表符、换行符等）   [] 匹配括号内的任意一个字符（如 [abc] 匹配 a、b 或 c...</div></div></div></a><a class="pagination-related" href="/2025/09/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="go语言学习第一天"><img class="cover" src="/./img/aiguo.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-02</div><div class="info-item-2">go语言学习第一天</div></div><div class="info-2"><div class="info-item-1">先在官网下载配置了go，然后配环境变量又顺便熟悉了一下ai编辑器的用法，用go做了一个小游戏心得1.package main只能有一个2.感觉包、库管理很像python，而语法和结构又像C</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">feynman</div><div class="author-info-description">天下为公</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FeynmanNddbb"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="/./img/wechat.jpg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="/./img/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/" target="_blank" title="blog"><i class="fa-brands fa-reddit"></i></a><a class="social-icon" href="mailto:3553303315@qq.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">找不到页面不要惊慌，飞机还在慢慢完善！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">1.变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%AC%A6%E5%8F%B7-var-%E5%92%8C"><span class="toc-text">变量声明符号 var 和 :&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-text">常见的变量声明方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%AF%BC%E5%87%BA%E5%8F%98%E9%87%8F"><span class="toc-text">go 语言可导出变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%BA%A7%E5%8F%98%E9%87%8F"><span class="toc-text">包级变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BA%A7%E5%8F%98%E9%87%8F"><span class="toc-text">函数级变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83-shadow-%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">小心 shadow 的变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-go-%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F"><span class="toc-text">2.go 语言常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%B8%B8%E9%87%8F"><span class="toc-text">局部常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%8F%AF%E5%8C%85%E5%90%AB%E8%AE%A1%E7%AE%97"><span class="toc-text">常量不可包含计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F-iota"><span class="toc-text">枚举常量 iota</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B"><span class="toc-text">3.泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%98%AF%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%BA%A6%E6%9D%9F%E6%98%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-text">泛型是类型，约束是类型的约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-text">约束的嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E7%9A%84%E6%B3%9B%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94"><span class="toc-text">跟其它语言的泛型进行对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B0%B1%E5%AE%8C%E6%88%90%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%A3%85%E7%AE%B1%E6%93%8D%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="toc-text">为什么 Java 编译器不在编译期就完成泛型的装箱操作呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%AD%90%E5%AD%A6%E6%B3%9B%E5%9E%8B"><span class="toc-text">用例子学泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B3%9B%E5%9E%8B-map-filter-reduce"><span class="toc-text">函数泛型 map-filter-reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E6%B3%9B%E5%9E%8B-sets"><span class="toc-text">例子二：方法上的泛型 sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E4%B8%89%EF%BC%9A%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BA%A6%E6%9D%9F-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsort%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">例子三：外部定义的约束 实现一个sort接口类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#issues"><span class="toc-text">issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%80%BC"><span class="toc-text">关于泛型中的零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BA%86%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B"><span class="toc-text">无法识别使用了底层数据的其它类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B3%E4%BE%BF%E7%BA%A6%E6%9D%9F%E4%B8%80%E8%87%B4%EF%BC%8C%E7%B1%BB%E5%9E%8B%E4%B9%9F%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84"><span class="toc-text">即便约束一致，类型也是不同的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">4.错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-text">错误处理的基本认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Error 的本质是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-error"><span class="toc-text">自定义 error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-Is"><span class="toc-text">errors.Is()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-As"><span class="toc-text">errors.As()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errors-Join"><span class="toc-text">errors.Join()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%81%87%E5%88%B0%E4%BA%86-defer"><span class="toc-text">当错误处理遇到了 defer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">错误处理实战的五种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">经典的错误处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">屏蔽过程中的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">分层架构中的错误处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pkg-errors"><span class="toc-text">pkg&#x2F;errors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errgroup-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">errgroup 的使用技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7"><span class="toc-text">错误处理相关技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-errors-New-%E6%97%B6%E8%A6%81%E5%86%99%E6%B8%85%E6%A5%9A%E5%8C%85%E5%90%8D"><span class="toc-text">使用 errors.New() 时要写清楚包名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-error-%E5%A4%84%E7%90%86%E4%B8%80%E8%88%AC%E9%94%99%E8%AF%AF%EF%BC%8C%E4%BD%BF%E7%94%A8-panic-%E5%A4%84%E7%90%86%E4%B8%A5%E9%87%8D%E9%94%99%E8%AF%AF-%E5%BC%82%E5%B8%B8"><span class="toc-text">使用 error 处理一般错误，使用 panic 处理严重错误 (异常)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%8C%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-error-types"><span class="toc-text">基础库，应该避免使用 error types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%8F%98%E5%BE%97%E6%9B%B4%E7%AE%80%E6%B4%81"><span class="toc-text">优化不必要的代码让程序变得更简洁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%BA%94%E8%AF%A5%E5%8F%AA%E5%A4%84%E7%90%86%E4%B8%80%E6%AC%A1"><span class="toc-text">错误应该只处理一次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1-code-%E7%A0%81%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-text">业务 code 码的设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BE%8B%E8%BF%94%E5%9B%9E-http-status-200%EF%BC%8C%E5%85%B7%E4%BD%93-code-%E7%A0%81%E5%8D%95%E7%8B%AC%E8%AE%BE%E7%BD%AE"><span class="toc-text">一律返回 http status 200，具体 code 码单独设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84-http-status-code-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BF%A1%E6%81%AF%E4%BB%A5%E5%8F%8A%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">使用合适的 http status code + 简单的信息以及业务错误代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84-http-status-code-%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E4%BF%A1%E6%81%AF"><span class="toc-text">使用合适的 http status code + 非常详细的业务错误代码以及信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1-code-%E7%A0%81%E7%9A%84%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">业务 code 码的具体设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-http-status-code"><span class="toc-text">如何设置 http status code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E7%BA%A7%E7%9A%84%E9%94%99%E8%AF%AF%E5%8C%85"><span class="toc-text">设计一个生产级的错误包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%BA%A7%E7%9A%84%E9%94%99%E8%AF%AF%E5%8C%85%E9%9C%80%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">生产级的错误包需要的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#issues-1"><span class="toc-text">issues</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/" title="焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链"><img src="/./img/aiguo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链"/></a><div class="content"><a class="title" href="/2025/09/18/%E7%84%A6%E5%8C%96%E5%B7%A5%E8%89%BA%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%92%A2%E9%93%81%E5%B7%A5%E4%B8%9A%E7%9A%84%E8%83%BD%E6%BA%90%E6%9E%A2%E7%BA%BD%E4%B8%8E%E5%8C%96%E5%AD%A6%E4%BB%B7%E5%80%BC%E9%93%BE/" title="焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链">焦化工艺全景解析：钢铁工业的能源枢纽与化学价值链</a><time datetime="2025-09-18T06:33:48.000Z" title="发表于 2025-09-18 14:33:48">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/" title="加强学习第一天（四节）"><img src="/./img/aiguo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加强学习第一天（四节）"/></a><div class="content"><a class="title" href="/2025/09/17/%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9B%9B%E8%8A%82%EF%BC%89/" title="加强学习第一天（四节）">加强学习第一天（四节）</a><time datetime="2025-09-17T08:26:38.000Z" title="发表于 2025-09-17 16:26:38">2025-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/" title="评论专区"><img src="/./img/aiguo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="评论专区"/></a><div class="content"><a class="title" href="/2025/09/15/%E8%AF%84%E8%AE%BA%E4%B8%93%E5%8C%BA/" title="评论专区">评论专区</a><time datetime="2025-09-15T07:05:39.000Z" title="发表于 2025-09-15 15:05:39">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" title="经验教训"><img src="/./img/aiguo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经验教训"/></a><div class="content"><a class="title" href="/2025/09/15/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" title="经验教训">经验教训</a><time datetime="2025-09-15T05:45:12.000Z" title="发表于 2025-09-15 13:45:12">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="go项目基础第一天"><img src="/./img/aiguo.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go项目基础第一天"/></a><div class="content"><a class="title" href="/2025/09/15/go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="go项目基础第一天">go项目基础第一天</a><time datetime="2025-09-15T03:55:43.000Z" title="发表于 2025-09-15 11:55:43">2025-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By feynman</span></div><div class="footer_custom_text">have a nice day ！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://mytwikoo.midlight.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://mytwikoo.midlight.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer" data-id="9128477298" autoplay="true" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>